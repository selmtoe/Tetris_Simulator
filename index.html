<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" id="manifest-link">
<title>Tetris Simulator</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<style>
    :root {
        --bg-color: #1a1a2e; --primary-color: #4b4b7c; --primary-hover-color: #6a6aff;
        --font-color: #e0e0e0; --border-color: #4b4b7c; --canvas-bg-color: #0f0f18;
        --font-display: 'Orbitron', sans-serif; --font-ui: 'Noto Sans JP', sans-serif;
    }
    html, body {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        -webkit-tap-highlight-color: transparent;
    }
    body {
        background-color: var(--bg-color);
        color: var(--font-color);
        font-family: var(--font-ui);
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .main-container {
        text-align: center;
        transform-origin: center center;
    }
    #editor-container {
        display: flex; flex-direction: column; gap: 15px; background-color: rgba(15, 15, 24, 0.8);
        padding: 20px; border-radius: 10px; border: 2px solid var(--border-color);
        width: 100%; max-width: 1200px; margin-bottom: 20px;
    }
    #game-container { display: none; }
    canvas {
        background-color: var(--canvas-bg-color); border-radius: 8px;
        border: 2px solid var(--border-color);
    }
    h2 {
        font-family: var(--font-display); color: var(--primary-hover-color); margin: 0 0 10px 0;
        border-bottom: 2px solid var(--primary-color); padding-bottom: 5px; text-align: center;
    }
    .button, button, label.button {
        background-color: var(--primary-color); color: var(--font-color); border: none;
        padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 14px;
        font-family: var(--font-display); transition: background-color 0.2s;
        text-align: center; display: inline-block;
    }
    .button:hover, button:hover, label.button:hover { background-color: var(--primary-hover-color); }
    input[type="file"] { display: none; }

    .edit-section { background-color: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; }
    .top-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
    .mode-selection { display: flex; gap: 10px; align-items: center;}
    .mode-selection .button.active { background-color: var(--primary-hover-color); box-shadow: 0 0 10px var(--primary-hover-color); }

    .player-editors { display: flex; justify-content: space-around; gap: 20px; flex-wrap: nowrap; margin-top: 15px; }
    .editor-column { flex: 1; min-width: 320px; display: flex; flex-direction: column; gap: 15px; }

    .mino-icons, .color-palette { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    .mino-icon, .color-swatch {
        width: 40px; height: 40px; border-radius: 4px; cursor: pointer;
        border: 2px solid transparent; transition: all 0.2s; box-sizing: border-box;
    }
    .mino-icon:hover, .color-swatch:hover { transform: scale(1.1); }
    .color-swatch.active { border-color: #fff; box-shadow: 0 0 8px #fff; }

    .next-queue-display {
        background-color: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; min-height: 38px;
        display: flex; gap: 5px; flex-wrap: wrap; border: 1px solid var(--primary-color);
    }
    .next-queue-display .mino-icon { cursor: default; }
    .editor-column .button-group { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }

    .field-editor canvas { margin-bottom: 10px; cursor: crosshair; touch-action: none; }
    .field-controls { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;}

    #startGameBtn { font-size: 24px; padding: 12px 25px; background-color: #00a000; }
    #startGameBtn:hover { background-color: #00c000; }

    #scan-instructions {
        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8); color: white; padding: 10px 20px;
        border-radius: 10px; font-size: 18px; z-index: 100;
    }
    
#settings-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        display: none; justify-content: center; align-items: center; z-index: 200;
    }
    .modal-content {
        background-color: var(--bg-color); padding: 25px; border-radius: 10px;
        border: 2px solid var(--primary-color); width: 90%; max-width: 500px;
        font-family: var(--font-ui);
    }
    .modal-content h2, .modal-content h3 { font-size: 24px; }
    .modal-content h3 { font-size: 20px; margin-top: 25px; border-top: 1px solid var(--primary-color); padding-top: 15px; }
#settings-list, .key-config-list-container { display: flex; flex-direction: column; gap: 12px; margin: 20px 0; }
    .key-config-item, .setting-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; border-radius: 4px; }
    .key-config-item:nth-child(odd), .setting-item:nth-child(odd) { background-color: rgba(255,255,255,0.05); }
    .key-config-item span, .setting-item span, .setting-item label { font-size: 16px; color: var(--font-color); }
    .key-config-item button, .setting-item input { min-width: 150px; text-align: center; }
    .setting-item input[type="number"] { background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 5px; border-radius: 4px; font-family: var(--font-display); }
    .setting-item input[type="checkbox"] { width: 20px; height: 20px; min-width: 20px; }
    .setting-item label { display: flex; align-items: center; gap: 10px; }
    .modal-controls { text-align: center; margin-top: 15px; }

    #share-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        display: none; justify-content: center; align-items: center; z-index: 200;
    }
    .share-section h3 {
        font-family: var(--font-display);
        color: var(--primary-hover-color);
        margin-top: 0;
        margin-bottom: 10px;
        border-bottom: 1px solid var(--primary-color);
        padding-bottom: 5px;
    }
    .share-item {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    #share-modal .modal-content input, #share-modal .modal-content textarea {
        background-color: var(--primary-color);
        color: var(--font-color);
        border: 1px solid var(--border-color);
        padding: 8px;
        border-radius: 4px;
        font-family: var(--font-ui);
    }
    
   
    #virtual-controller-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 150;
        display: none;
    }
    #virtualControllerCanvas {
        display: block;
        width: 100%;
        height: 100%;
        background-color: transparent;
        border: none;
    }
    #vc-edit-controls {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 151;
        background: rgba(50, 50, 50, 0.9);
        padding: 10px 20px;
        border-radius: 8px;
        display: flex;
        gap: 15px;
        align-items: center;
    }

.modal-tabs {
    display: flex;
    border-bottom: 2px solid var(--primary-color);
    margin-bottom: 10px;
}
.tab-button {
    flex: 1;
    padding: 10px 15px;
    cursor: pointer;
    background-color: transparent;
    border: none;
    color: var(--font-color);
    font-family: var(--font-display);
    font-size: 16px;
    border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s;
}
.tab-button:hover {
    background-color: rgba(255, 255, 255, 0.1);
}
.tab-button.active {
    color: var(--primary-hover-color);
    border-bottom: 3px solid var(--primary-hover-color);
}
.tab-content {
    display: none;
}
.tab-content.active {
    display: block;
    animation: fadeIn 0.3s ease-in-out;
}
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

</style>
</head>
<body>

<div class="main-container">
    <div id="editor-container">
        <div class="edit-section top-controls">
            <div class="mode-selection">
                <h2>MODE</h2>
                <div class="button active" id="mode-1p">1P</div>
                <div class="button" id="mode-2p">2P</div>
                <div class="button" id="mode-ai" style="opacity: 0.5; cursor: not-allowed;" title="実装予定">AI</div>
                <button id="settingsBtn" class="button" style="margin-left: 15px;">設定</button>
                 <button id="shareBtn" class="button" style="margin-left: 5px;">共有</button>
                 <button id="ruleBtn" class="button" style="margin-left: 5px;">ルール</button>
            </div>
            <button id="startGameBtn" class="button">START GAME</button>
        </div>

<div class="player-editors">
            <div class="editor-column" id="p1-editor-col">
                <div class="edit-section next-editor">
                    <h2>PLAYER 1 - NEXT</h2>
                    <div class="mino-icons" id="p1-next-icons"></div>
                    <div class="next-queue-display" id="p1-next-queue"></div>
                    <div class="button-group">
                        <button class="button" id="p1-next-delete-left">Delete</button>
                        <button class="button" id="p1-next-clear">Clear</button>
                    </div>
                </div>
                <div class="edit-section field-editor">
                    <h2>PLAYER 1 - FIELD</h2>
                    <div class="color-palette" id="p1-palette"></div>

<canvas id="field-editor-canvas-p1"></canvas>
                    <div class="field-controls">
                        <button class="button" id="p1-field-shift-up">↑ Up</button>
                        <button class="button" id="p1-field-shift-down">↓ Down</button>
                        <button class="button" id="p1-field-clear">Clear</button>
                        <label for="imageLoader-p1" class="button">Load Img</label>
                        <input type="file" id="imageLoader-p1" data-player="p1" accept="image/*">
                        <label for="pptLoader-p1" class="button">Load PPT</label>
                        <input type="file" id="pptLoader-p1" data-player="p1" accept="image/*">
                    </div>
                    <div class="key-config-controls" style="margin-top: 15px; text-align: center;">

                        <button class="button" id="p1-key-config-btn">操作設定</button>
                    </div>
                </div>
            </div>
<div class="editor-column" id="p2-editor-col" style="display: none;">
                <div class="edit-section next-editor">
                    <h2>PLAYER 2 - NEXT</h2>
                    <div class="mino-icons" id="p2-next-icons"></div>
                    <div class="next-queue-display" id="p2-next-queue"></div>
                    <div class="button-group">
                        <button class="button" id="p2-next-delete-left">Delete</button>
                        <button class="button" id="p2-next-clear">Clear</button>
                    </div>
                </div>
                <div class="edit-section field-editor">
                    <h2>PLAYER 2 - FIELD</h2>
                    <div class="color-palette" id="p2-palette"></div>

<canvas id="field-editor-canvas-p2"></canvas>
                    <div class="field-controls">
                        <button class="button" id="p2-field-shift-up">↑ Up</button>
                        <button class="button" id="p2-field-shift-down">↓ Down</button>
                        <button class="button" id="p2-field-clear">Clear</button>
                        <label for="imageLoader-p2" class="button">Load Img</label>
                        <input type="file" id="imageLoader-p2" data-player="p2" accept="image/*">
                        <label for="pptLoader-p2" class="button">Load PPT</label>
                        <input type="file" id="pptLoader-p2" data-player="p2" accept="image/*">
                    </div>
                    <div class="key-config-controls" style="margin-top: 15px; text-align: center;">

                        <button class="button" id="p2-key-config-btn">操作設定</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<div id="game-container">
<div id="rule-description-display" style="display: none; position: absolute; z-index: 155; color: var(--font-color); background: rgba(26, 26, 46, 0.9); padding: 15px; border-radius: 10px; border: 2px solid #4b4b7c; font-family: var(--font-ui); font-size: 14px; max-width: 200px; max-height: 400px; overflow-y: auto; box-sizing: border-box; word-wrap: break-word; backdrop-filter: blur(4px);"></div>
<canvas id="mainCanvas"></canvas>
<div id="scan-instructions" style="display: none;"></div>

        <div id="scan-controls" style="display: none; margin-top: 15px; gap: 10px; justify-content:center;">
             <button id="scanConfirmBtn" class="button">次へ</button>
             <button id="scanCancelBtn" class="button">キャンセル</button>
        </div>
    </div>
</div>

<div id="game-controls" style="display: none; position: fixed; top: 10px; right: 10px; z-index: 160; gap: 10px;">
     <button id="retryBtn" class="button">リトライ</button>
     <button id="backToEditorBtn" class="button">戻る</button>
</div>

<div id="virtual-controller-container">

    <div id="vc-edit-controls" style="display: none;">
        <button id="vc-save-and-close-btn" class="button">保存して閉じる</button>
    </div>
    <canvas id="virtualControllerCanvas"></canvas>
</div>

<div id="settings-modal">
    <div class="modal-content">
        <div class="modal-tabs">
            <button class="tab-button active" data-tab="general">諸設定</button>
            <button class="tab-button" data-tab="p1-keys">1P操作設定</button>
            <button class="tab-button" data-tab="p2-keys" id="p2-keys-tab-btn" style="display: none;">2P操作設定</button>
        </div>

        <div class="tab-content active" id="tab-content-general">
             <h2 style="margin-top: 20px;">ゲーム設定</h2>
             <p></p>
             <div id="settings-list"></div>
        </div>

        <div class="tab-content" id="tab-content-p1-keys">
            <h2 style="margin-top: 20px;">PLAYER 1 - 操作設定</h2>
            <p></p>
            <div id="p1-key-config-list" class="key-config-list-container"></div>
            
            <h3><br>タッチ操作設定 (P1)</h3>
            <p></p>
            <div class="modal-controls" style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                <button id="vc-edit-layout-btn" class="button">ボタン配置モードへ</button>
                <button id="vc-copy-layout-btn" class="button">配置をコピー</button>
                <button id="vc-paste-layout-btn" class="button">配置をインポート</button>
            </div>
        </div>
        
        <div class="tab-content" id="tab-content-p2-keys">
            <h2 style="margin-top: 20px;">PLAYER 2 - 操作設定</h2>
            <p></p>
            <div id="p2-key-config-list" class="key-config-list-container"></div>
        </div>
        
        <div class="modal-controls" style="border-top: 1px solid var(--primary-color); padding-top: 15px; margin-top: 20px;">
            <button id="settings-close" class="button">保存して閉じる</button>
        </div>
    </div>
</div>

<div id="share-modal">
    <div class="modal-content">
        <h2>共有</h2>
        
        <div class="share-section">
            <h3>エクスポート</h3>
            <p></p>
            <div class="share-item">
                <span>共有リンク</span>
                <input type="text" id="share-link-input" readonly style="width: 100%; margin-top: 5px; margin-bottom: 5px; box-sizing: border-box;">
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                    <button id="copy-link-btn" class="button">リンクをコピー</button>
                    <button id="advanced-link-btn" class="button">詳細なリンク生成</button>
                </div>
            </div>
            <div id="advanced-link-options" style="display: none; margin-top: 15px; padding: 10px; background-color: rgba(255,255,255,0.05); border-radius: 5px;">
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="start-sim-checkbox">
                        <span>シミュレーションを即スタート</span>
                    </label>
                </div>
<div class="setting-item">
                    <label>
                        <input type="checkbox" id="no-hold-checkbox">
                        <span>ホールドを禁止</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="hide-back-btn-checkbox" disabled>
                        <span>戻るボタンを非表示</span>
                    </label>
                </div>
                 <button id="generate-advanced-link-btn" class="button" style="margin-top: 10px;">リンクを再生成</button>
            </div>
        </div>
        
        <hr style="border-color: var(--primary-color); margin: 20px 0;">
        

        <div class="share-section">
            <h3>インポート</h3>
            <p></p>
            <button id="import-from-data-btn" class="button">クリップボードからインポート</button>
        </div>


        <div class="modal-controls">
            <button id="share-close" class="button">閉じる</button>
        </div>
    </div>
</div>

<div id="rule-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; z-index: 200;">
    <div class="modal-content" style="width: 90%; max-width: 700px;">
        <h2>カスタムルール</h2>
        
        <div class="rule-section" style="margin-bottom: 20px;">
            <h3>説明</h3>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 10px;">ここに記述した内容は、ゲーム画面の左側（ホールドの下）に表示されます。</p>
            <textarea id="rule-description-input" style="width: 100%; height: 100px; background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 4px; font-family: var(--font-ui); box-sizing: border-box; resize: vertical;"></textarea>
        </div>

        <div class="rule-section">
            <h3>コード (JS)</h3>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 10px;">ゲームのクリア・オーバー条件などをプログラムで定義します。</p>
            <textarea id="rule-code-input" style="width: 100%; height: 250px; background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 4px; font-family: monospace; box-sizing: border-box; resize: vertical;"></textarea>
        </div>

        <div class="modal-controls" style="border-top: 1px solid var(--primary-color); padding-top: 15px; margin-top: 20px;">
            <button id="rule-save-close" class="button">保存して閉じる</button>
            <button id="rule-close" class="button">キャンセル</button>
        </div>
    </div>
</div>

<script>

const virtualController = (() => {

    let container, canvas, ctx, editControls;

    let mode = 'play';
    let layouts = {};
    let buttons = {};
    let selectedButtonId = null;
    let isDraggingButton = false;
    let isDraggingSlider = false;
    const activeTouches = {};

   
    const defaultLayout = {
        portrait: {
            'left':      { label: '←', x: 0.12, y: 0.82, r: 0.08 },
            'right':     { label: '→', x: 0.32, y: 0.82, r: 0.08 },
            'softDrop':  { label: '↓', x: 0.22, y: 0.92, r: 0.07 },
            'hardDrop':  { label: '↑', x: 0.22, y: 0.72, r: 0.07 },
            'rotateCCW': { label: 'L',  x: 0.65, y: 0.85, r: 0.10 },
            'rotateCW':  { label: 'R',  x: 0.85, y: 0.85, r: 0.10 },
            'hold':      { label: 'H',  x: 0.75, y: 0.68, r: 0.09 },
        },
        landscape: {
            'left':      { label: '←', x: 0.10, y: 0.75, r: 0.08 },
            'right':     { label: '→', x: 0.25, y: 0.75, r: 0.08 },
            'softDrop':  { label: '↓', x: 0.175,y: 0.90, r: 0.07 },
            'hardDrop':  { label: '↑', x: 0.175,y: 0.60, r: 0.07 },
            'rotateCCW': { label: 'L',  x: 0.80, y: 0.85, r: 0.10 },
            'rotateCW':  { label: 'R',  x: 0.90, y: 0.65, r: 0.10 },
            'hold':      { label: 'H',  x: 0.75, y: 0.60, r: 0.09 },
        }
    };
    
    function init() {
        container = document.getElementById('virtual-controller-container');
        canvas = document.getElementById('virtualControllerCanvas');
        ctx = canvas.getContext('2d');
        editControls = document.getElementById('vc-edit-controls');

        loadLayouts();
        handleResize();

        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize);

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false });
        

        let isMouseDown = false;
        const convertMouseEvent = (e) => ({ changedTouches: [{ clientX: e.clientX, clientY: e.clientY, identifier: -1 }], preventDefault: () => {} });
        canvas.addEventListener('mousedown', (e) => { isMouseDown = true; handleStart(convertMouseEvent(e)); });
        canvas.addEventListener('mousemove', (e) => { if (isMouseDown) handleMove(convertMouseEvent(e)); });
        window.addEventListener('mouseup', (e) => { if (isMouseDown) { isMouseDown = false; handleEnd(convertMouseEvent(e)); } });
    }

    function show() { if (container) container.style.display = 'block'; handleResize(); }
    function hide() { if (container) container.style.display = 'none'; }

    function startEditMode() {
        show();
        mode = 'edit';
        editControls.style.display = 'flex';
        selectedButtonId = null;
        draw();
    }

    function endEditMode() {
        mode = 'play';
        editControls.style.display = 'none';
        saveLayouts();
        if (gameState !== 'PLAYING') {
            hide();
        }
        draw();
    }
    
    function handleResize() {
        if (!canvas) return;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const orientation = (canvas.width > canvas.height) ? 'landscape' : 'portrait';
       
        if (!layouts[orientation] || Object.keys(layouts[orientation]).length === 0) {
            layouts[orientation] = JSON.parse(JSON.stringify(defaultLayout[orientation]));
        }
        
        buttons = layouts[orientation];
       
        for(const id in buttons) {
            if (buttons[id].isPressed === undefined) {
                buttons[id].isPressed = false;
            }
        }
        
        draw();
    }

    function draw() {
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const shortSide = Math.min(canvas.width, canvas.height);

        for (const id in buttons) {
            const btn = buttons[id];
            const x = btn.x * canvas.width;
            const y = btn.y * canvas.height;
            const r = btn.r * shortSide;

            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            if (btn.isPressed || (mode === 'edit' && id === selectedButtonId)) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
            }
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = `bold ${r * 0.7}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(btn.label, x, y);
        }

        if (mode === 'edit' && selectedButtonId) {
            drawSizeSlider(shortSide);
        }
    }

    function drawSizeSlider(shortSide) {
        const centerX = canvas.width / 2;
        const y = canvas.height / 2;
        const sliderWidth = shortSide * 0.5;
        const minR = 0.04, maxR = 0.20;

        ctx.beginPath();
        ctx.moveTo(centerX - sliderWidth / 2, y);
        ctx.lineTo(centerX + sliderWidth / 2, y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 5;
        ctx.stroke();

        const btn = buttons[selectedButtonId];
        const ratio = (btn.r - minR) / (maxR - minR);
        const handleX = (centerX - sliderWidth / 2) + sliderWidth * ratio;
        
        ctx.beginPath();
        ctx.arc(handleX, y, shortSide * 0.03, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
    }

    function handleStart(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        const shortSide = Math.min(canvas.width, canvas.height);

        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const touchX = touch.clientX, touchY = touch.clientY;

            if (mode === 'play') {
                const buttonId = getButtonAt(touchX, touchY, shortSide);
                if (buttonId) {
                    pressButton(buttonId);
                    activeTouches[touch.identifier] = buttonId;
                }
            } else {
                const sliderHit = checkSliderHit(touchX, touchY, shortSide);
                if (sliderHit) {
                    isDraggingSlider = true;
                    activeTouches[touch.identifier] = 'slider';
                    updateSlider(touchX, shortSide);
                    return;
                }
                const buttonId = getButtonAt(touchX, touchY, shortSide);
                if (buttonId) {
                    selectedButtonId = buttonId;
                    isDraggingButton = true;
                    activeTouches[touch.identifier] = buttonId;
                } else {
                    selectedButtonId = null;
                }
            }
        }
        draw();
    }

    function handleMove(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        const shortSide = Math.min(canvas.width, canvas.height);

        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const touchId = touch.identifier;
            const touchX = touch.clientX, touchY = touch.clientY;

            if (mode === 'play') {
                const prevButtonId = activeTouches[touchId];
                const currentButtonId = getButtonAt(touchX, touchY, shortSide);
                if (prevButtonId !== currentButtonId) {
                    if (prevButtonId) releaseButton(prevButtonId);
                    if (currentButtonId) pressButton(currentButtonId);
                    activeTouches[touchId] = currentButtonId;
                }
            } else {
                if (isDraggingSlider && activeTouches[touchId] === 'slider') {
                    updateSlider(touchX, shortSide);
                } else if (isDraggingButton && activeTouches[touchId] === selectedButtonId) {
                    const btn = buttons[selectedButtonId];
                    btn.x = touchX / canvas.width;
                    btn.y = touchY / canvas.height;
                }
            }
        }
        draw();
    }

    function handleEnd(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        for (let i = 0; i < touches.length; i++) {
            const touchId = touches[i].identifier;
            if (mode === 'play') {
                const buttonId = activeTouches[touchId];
                if (buttonId) releaseButton(buttonId);
            } else {
                if (isDraggingButton) isDraggingButton = false;
                if (isDraggingSlider) isDraggingSlider = false;
            }
            delete activeTouches[touchId];
        }
        draw();
    }

    function getButtonAt(x, y, shortSide) {
     
        const buttonIds = Object.keys(buttons).reverse();
        for (const id of buttonIds) {
            const btn = buttons[id];
            const btnX = btn.x * canvas.width;
            const btnY = btn.y * canvas.height;
            const btnR = btn.r * shortSide;
            if (Math.sqrt((x - btnX) ** 2 + (y - btnY) ** 2) <= btnR) {
                return id;
            }
        }
        return null;
    }

    function pressButton(id) {
        const btn = buttons[id];
        if (btn && !btn.isPressed) {
            btn.isPressed = true;

            if (['hardDrop', 'rotateCW', 'rotateCCW', 'hold'].includes(id)) {
                if(players.length > 0) players[0].handlePress(id);
            }
        }
    }
    
    function releaseButton(id) {
        const btn = buttons[id];
        if (btn) btn.isPressed = false;
    }

    function checkSliderHit(x, y, shortSide) {
        if (!selectedButtonId) return false;
        const centerX = canvas.width / 2, sliderY = canvas.height / 2;
        const sliderWidth = shortSide * 0.5, handleRadius = shortSide * 0.03;
        const minR = 0.04, maxR = 0.20;
        const ratio = (buttons[selectedButtonId].r - minR) / (maxR - minR);
        const handleX = (centerX - sliderWidth / 2) + sliderWidth * ratio;
        return Math.sqrt((x - handleX) ** 2 + (y - sliderY) ** 2) <= handleRadius;
    }

    function updateSlider(touchX, shortSide) {
        if (!selectedButtonId) return;
        const centerX = canvas.width / 2, sliderWidth = shortSide * 0.5;
        const sliderStart = centerX - sliderWidth / 2;
        const clampedX = Math.max(sliderStart, Math.min(touchX, sliderStart + sliderWidth));
        const newRatio = (clampedX - sliderStart) / sliderWidth;
        const minR = 0.04, maxR = 0.20;
        buttons[selectedButtonId].r = minR + (maxR - minR) * newRatio;
    }

    function saveLayouts() {
        try {
            localStorage.setItem('tetrisVirtualPadLayouts', JSON.stringify(layouts));
        } catch (e) {
            console.error("Failed to save virtual pad layouts:", e);
        }
    }

    function loadLayouts() {
        try {
            const savedLayouts = JSON.parse(localStorage.getItem('tetrisVirtualPadLayouts'));
            if (savedLayouts && savedLayouts.portrait && savedLayouts.landscape) {
                layouts = savedLayouts;
            } else {
                layouts = JSON.parse(JSON.stringify(defaultLayout));
            }
        } catch (e) {
            console.error("Failed to load virtual pad layouts:", e);
            layouts = JSON.parse(JSON.stringify(defaultLayout));
        }
    }

    async function copyLayoutsToClipboard() {
        try {
            await navigator.clipboard.writeText(JSON.stringify(layouts, null, 2));
            alert('ボタン配置をクリップボードにコピーしました。');
        } catch (err) {
            alert('コピーに失敗しました。');
            console.error('Failed to copy layouts: ', err);
        }
    }

    async function importLayoutsFromClipboard() {
        if (!confirm('クリップボードからボタン配置を読み込みますか？現在の配置は上書きされます。')) return;
        try {
            const text = await navigator.clipboard.readText();
            const newLayouts = JSON.parse(text);
            if (newLayouts && newLayouts.portrait && newLayouts.landscape) {
                layouts = newLayouts;
                saveLayouts();
                handleResize();
                alert('ボタン配置をインポートしました。');
            } else {
                alert('無効なデータ形式です。');
            }
        } catch (err) {
            alert('インポートに失敗しました。');
            console.error('Failed to paste layouts: ', err);
        }
    }
    
    return {
        init,
        show,
        hide,
        startEditMode,
        endEditMode,
        isButtonPressed: (action) => buttons[action]?.isPressed || false,
        copyLayoutsToClipboard,
        importLayoutsFromClipboard
    };
})();

const RESOLUTION_SCALE = 2;
const BLOCK_SIZE = 28;
const EDITOR_BLOCK_SIZE = 50;
const BOARD_WIDTH = 10;
const BOARD_VISIBLE_HEIGHT = 20;
const BOARD_HEIGHT = 40; 
const HOLD_AREA_WIDTH = 5 * BLOCK_SIZE;
const PLAYFIELD_WIDTH = BOARD_WIDTH * BLOCK_SIZE;
const NEXT_AREA_WIDTH = 5 * BLOCK_SIZE;
const PADDING = 20;
const PLAYER_CANVAS_WIDTH = HOLD_AREA_WIDTH + PLAYFIELD_WIDTH + NEXT_AREA_WIDTH + PADDING * 2;
const CANVAS_HEIGHT = (BOARD_VISIBLE_HEIGHT + 0.5) * BLOCK_SIZE;
const PLAYFIELD_X_OFFSET = HOLD_AREA_WIDTH + PADDING;
const AXIS_THRESHOLD = 0.8;

let gameSettings = {
    das: 140,
    arr: 30,
    sdf: 20,
    lineClearDelay: 0,
    gravity: 9999999,
    lockDelay: 9999999,
    garbageGrace: 1000,
    garbageRandomness: 0.3,
    maxNext: 5,
    showEffects: true,
    touchControlsEnabled: 'ontouchstart' in window,
};

const COLORS = { 'I': '#00f0f0', 'O': '#f0f000', 'T': '#a000f0', 'L': '#f0a000', 'J': '#0000f0', 'S': '#00f000', 'Z': '#f00000', 'G': '#999999', 'E': '#808080' };

const SCAN_COLOR_PALETTE = {
    'NULL': ['#000000', '#302838'],
    'G':    ['#999999', '#D8D8D8'],
    'I':    ['#019899', '#0199D5'],
    'O':    ['#999A02', '#F9B900'],
    'T':    ['#980099', '#871E88'],
    'L':    ['#996700', '#F56100'],
    'J':    ['#0000BB', '#004BA5'],
    'S':    ['#10971F', '#5CB523'],
    'Z':    ['#990000', '#DA1822']
};

const hexToRgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
};

const PARSED_SCAN_COLORS = {};
for (const key in SCAN_COLOR_PALETTE) {
    PARSED_SCAN_COLORS[key] = SCAN_COLOR_PALETTE[key].map(hexToRgb);
}


const SCAN_COLORS = { ...COLORS, 'O': '#999A02', 'L': '#f0a000' };
const MINO_SKINS = { default: COLORS };
let activeSkin = MINO_SKINS.default;

const EDITOR_COLORS = {...COLORS, 'EMPTY': '#000000'};
const TETROMINOS = {
    'I': { shape: [[0, 0], [1, 0], [2, 0], [3, 0]], center: [1.5, 0.5] }, 'O': { shape: [[0, 0], [1, 0], [0, -1], [1, -1]], center: [0.5, -0.5] },
    'T': { shape: [[0, 0], [-1, 0], [0, -1], [1, 0]], center: [0, 0] }, 'L': { shape: [[-1, 0], [0, 0], [1, 0], [1, -1]], center: [0, 0] },
    'J': { shape: [[0, 0], [-1, 0], [1, 0], [-1, -1]], center: [0, 0] }, 'S': { shape: [[1, -1], [-1, 0], [0, 0], [0, -1]], center: [0, 0] },
    'Z': { shape: [[0, 0], [1, 0], [0, -1], [-1, -1]], center: [0, 0] }
};
const SRS_OFFSETS = { "JLSTZ": { "0_1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], "1_0": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], "1_2": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], "2_1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], "2_3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], "3_2": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], "3_0": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], "0_3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], }, "I": { "0_1": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], "1_0": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], "1_2": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]], "2_1": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], "2_3": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], "3_2": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], "3_0": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], "0_3": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]], } };

let players = [], gameMode = '1P', gameState = 'EDITING', lastTime = 0, mainCanvas, ctx;

let keyBindings = {
    p1: {
        left:      { type: 'key', value: 'a',           label: 'a' },
        right:     { type: 'key', value: 'd',           label: 'd' },
        softDrop:  { type: 'key', value: 's',           label: 's' },
        hardDrop:  { type: 'key', value: ' ',           label: 'Space' },
        rotateCW:  { type: 'key', value: 'e',           label: 'e' },
        rotateCCW: { type: 'key', value: 'q',           label: 'q' },
        hold:      { type: 'key', value: 'w',           label: 'w' },
    },
    p2: {
        left:      { type: 'key', value: 'arrowleft',   label: 'ArrowLeft' },
        right:     { type: 'key', value: 'arrowright',  label: 'ArrowRight' },
        softDrop:  { type: 'key', value: 'arrowdown',   label: 'ArrowDown' },
        hardDrop:  { type: 'key', value: 'enter',       label: 'Enter' },
        rotateCW:  { type: 'key', value: 'arrowup',     label: 'ArrowUp' },
        rotateCCW: { type: 'key', value: '.',           label: '.' },
        hold:      { type: 'key', value: '/',           label: '/' },
    }
};
const keyActionLabels = {
    left: '左移動', right: '右移動', softDrop: 'ソフトドロップ',
    rotateCW: '右回転', rotateCCW: '左回転',
    hardDrop: 'ハードドロップ', hold: 'ホールド'
};
let isBindingKey = false, bindingPlayer = null, bindingAction = null;
let gamepads = {}, prevGamepads = {};

const editorData = {
    p1: { board: null, nextQueue: [], hold: null, viewY: BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT, activeColor: 'I', nextInsertionIndex: -1 },
    p2: { board: null, nextQueue: [], hold: null, viewY: BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT, activeColor: 'I', nextInsertionIndex: -1 },
    rule: { description: '', code: '' }
};

let scanState = { image: null, bottomLeft: null, topRight: null, currentMousePos: {x: 0, y: 0}, targetPlayerId: null, parsedColors: null };

function* createMinoGenerator(customQueue) {
    if (customQueue && customQueue.length > 0) {
        yield* customQueue;
    }
    const bag = [];
    const pieces = Object.keys(TETROMINOS);
    while (true) {
        if (bag.length === 0) {
            const newBag = [...pieces];
            for (let i = newBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newBag[i], newBag[j]] = [newBag[j], newBag[i]];
            }
            bag.push(...newBag);
        }
        yield bag.shift();
    }
}

class Player {
    constructor(id, offsetX, keyBindings, padIndex) {
        this.id = id; this.offsetX = offsetX; this.keyBindings = keyBindings; this.padIndex = padIndex;
        this.keys = {};
        const pData = editorData[`p${id}`];
        this.initialHold = pData.hold;
        this.board = pData.board.map(row => [...row]);
        this.minoGenerator = createMinoGenerator(pData.nextQueue);
        this.opponent = null;
        this.holdDisabled = false;
        this.ruleHooks = {};
        this.gameApi = null;
        this.reset();
    }

reset() {
        this.player = { x: 0, y: 0, pieceType: null, rotation: 0 };
        this.nextQueue = [];
        for (let i = 0; i < gameSettings.maxNext; i++) {
            this.nextQueue.push(this.minoGenerator.next().value);
        }
        this.holdPiece = this.initialHold; this.canHold = true; this.gravityTimer = gameSettings.gravity; this.lockTimer = 0;
        this.dasTimer = 0; this.arrTimer = 0; this.sdfTimer = 0; this.dasDirection = 0;
        this.isGrounded = false; this.gameOver = false; this.isClearingLine = false; this.lineClearDelayTimer = 0;
        this.gameClear = false;

        this.stats = {
            tSpinSingle: 0, tSpinDouble: 0, tSpinTriple: 0,
            miniTSpinSingle: 0, miniTSpinDouble: 0,
            perfectClear: 0, tetris: 0, ren: -1
        };

        this.viewY = BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT;
        this.pendingGarbage = 0;this.garbageQueue = []; this.ren = -1; this.isB2B = false;
        this.lastMoveWasRotation = false; this.lastSrsKickIndex = -1;
        this.specialMoveText = [];
        this.specialMoveTextTimer = 0;
        this.lastGarbageHoleX = -1;
        this.spawnNewPiece();
    }
    
    spawnNewPiece() {
        this.player.pieceType = this.nextQueue.shift();
        this.nextQueue.push(this.minoGenerator.next().value);
        
        this.player.rotation = 0;
        this.canHold = true;
        this.lastMoveWasRotation = false;
        this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;

        const shape = this.getShape(this.player.pieceType, this.player.rotation);
        this.player.y = 19;
        if (this.checkCollision(this.player.x, this.player.y, shape)) {
            this.player.y = 18;
            if (this.checkCollision(this.player.x, this.player.y, shape)) {

                 this.gameOver = true;
            }
        }
    }

    isActionPressed(action) {
        const binding = this.keyBindings[action];
        if (binding?.type === 'key' && this.keys[binding.value]) return true;
        
        if (this.padIndex !== null && gamepads[this.padIndex]) {
            if (binding?.type === 'pad_button' && gamepads[this.padIndex].buttons[binding.value]) return true;
            if (binding?.type === 'pad_axis') {
                const [axis, dir] = [parseInt(binding.value[0]), binding.value[1]];
                const axisValue = gamepads[this.padIndex].axes[axis];
                if ((dir === '+' && axisValue > AXIS_THRESHOLD) || (dir === '-' && axisValue < -AXIS_THRESHOLD)) return true;
            }
        }
        

        if (this.id === '1' && gameSettings.touchControlsEnabled) {
            if (virtualController.isButtonPressed(action)) return true;
        }

        return false;
    }

    handlePress(action) {
        if (this.gameOver || this.isClearingLine) return;
        switch (action) {
            case 'rotateCCW': this.rotate(-1); break;
            case 'rotateCW':  this.rotate(1); break;
            case 'hardDrop':  this.hardDrop(); break;
            case 'hold':      this.hold(); break;
        }
    }

update(dt) {
        if (this.gameOver || this.gameClear) return;

        if (this.ruleHooks.onUpdate && typeof this.ruleHooks.onUpdate === 'function') {
            try {
                this.ruleHooks.onUpdate(this.gameApi, this);
            } catch (e) {
                console.error("Rule error onUpdate:", e);
                this.gameOver = true;
                return;
            }
        }
        if (this.gameOver || this.gameClear) return;

        if (this.specialMoveTextTimer > 0) {
            this.specialMoveTextTimer -= dt;
        }

        this.processGarbageQueue();

        const left = this.isActionPressed('left');
        const right = this.isActionPressed('right');
        const horizDir = left ? -1 : (right ? 1 : 0);

        if (horizDir !== 0) {
            if (this.dasDirection !== horizDir) { 
                this.dasTimer = 0;
                this.arrTimer = 0;
                if (!this.isClearingLine) this.move(horizDir, 0);
            } else { 
                this.dasTimer += dt;
                if (this.dasTimer >= gameSettings.das) {
                    if (gameSettings.arr === 0) {
                        if (!this.isClearingLine) {
                            let successfulMoves = 0;
                            while (!this.checkCollision(this.player.x + horizDir, this.player.y, this.getShape(this.player.pieceType, this.player.rotation))) {
                                this.player.x += horizDir;
                                successfulMoves++;
                            }
                            if (successfulMoves > 0) {
                               this.lockTimer = 0;
                               this.lastMoveWasRotation = false;
                            }
                        }
                    } else {
                        this.arrTimer += dt;
                        if (this.arrTimer >= gameSettings.arr) {
                            if (!this.isClearingLine) this.move(horizDir, 0);
                            this.arrTimer -= gameSettings.arr;
                        }
                    }
                }
            }
        }
        this.dasDirection = horizDir;

if (this.isClearingLine) {
            this.lineClearDelayTimer -= dt;
            if (this.lineClearDelayTimer <= 0) { 
                this.isClearingLine = false; 
                this.riseGarbage(); 
                if (this.nextQueue[0] === 'E') {
                    if (this.holdPiece) {
                        this.player.pieceType = this.holdPiece;
                        this.holdPiece = null;
                        this.canHold = false;
                        
                        this.player.rotation = 0;
                        this.lockTimer = 0;
                        this.lastMoveWasRotation = false;
                        this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
                        const shape = this.getShape(this.player.pieceType, this.player.rotation);
                        this.player.y = 19;
                        if (this.checkCollision(this.player.x, this.player.y, shape)) {
                            this.player.y = 18;
                            if (this.checkCollision(this.player.x, this.player.y, shape)) {
                                 this.gameOver = true;
                            }
                        }
                        return;
                    } else {
                        this.gameOver = true;
                        return;
                    }
                }
                this.spawnNewPiece(); 
            }
            return;
        }

        if (this.isActionPressed('softDrop')) {
             if (gameSettings.sdf > 0) {
                this.sdfTimer += dt;
                if (this.sdfTimer >= gameSettings.sdf) {
                    this.move(0, 1);
                    this.sdfTimer -= gameSettings.sdf;
                }
             } else { 
                const ghostY = this.getGhostY();
                if (this.player.y < ghostY) {
                    this.player.y = ghostY;
                    this.lockTimer = 0;
                }
             }
        } else {
            this.sdfTimer = 0;
        }
        
        this.isGrounded = this.checkCollision(this.player.x, this.player.y + 1, this.getShape(this.player.pieceType, this.player.rotation));
        if (this.isGrounded) {
            this.lockTimer += dt;
            if (this.lockTimer >= gameSettings.lockDelay) {
                this.lockPiece();
            }
        } else {
            this.lockTimer = 0;
            if (!this.isActionPressed('softDrop')) {
                 if (gameSettings.gravity > 0) {
                    this.gravityTimer -= dt;
                    if (this.gravityTimer <= 0) {
                        this.move(0, 1, false);
                        this.gravityTimer += gameSettings.gravity;
                    }
                 } else { 
                    this.player.y = this.getGhostY();
                 }
            }
        }
    }

draw() {
        ctx.save(); ctx.translate(this.offsetX, 0);
        this.drawUI();

        ctx.save(); ctx.translate(PLAYFIELD_X_OFFSET, 0.5 * BLOCK_SIZE);
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, PLAYFIELD_WIDTH, CANVAS_HEIGHT);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 0.5;
        for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
        }
        ctx.strokeStyle = '#4b4b7c'; ctx.lineWidth = 2; ctx.strokeRect(1, 1, PLAYFIELD_WIDTH - 2, CANVAS_HEIGHT - 2);
        for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) { for (let x = 0; x < BOARD_WIDTH; x++) { const boardY = y + this.viewY; if (this.board[boardY]?.[x]) { this.drawBlock(this.board[boardY][x], x * BLOCK_SIZE, y * BLOCK_SIZE); } } }


        if (!this.gameOver && !this.gameClear && !this.isClearingLine && this.player.pieceType) { const shape = this.getShape(this.player.pieceType, this.player.rotation); const ghostY = this.getGhostY(); if (ghostY > this.player.y) this.drawPiece(shape, this.player.x, ghostY, this.player.pieceType, true); this.drawPiece(shape, this.player.x, this.player.y, this.player.pieceType, false); }
        this.drawSpecialMoveText();
        if (this.gameOver) this.drawMessage("GAME OVER");
        else if (this.gameClear) this.drawMessage("CLEAR!");
        ctx.restore(); ctx.restore();
    }
    
    getShape(p, r) { if(!p) return []; const o=TETROMINOS[p].shape; if(r===0||p==='O')return o; const c=TETROMINOS[p].center; return o.map(b=>{let [x,y]=[b[0]-c[0],b[1]-c[1]]; for(let i=0;i<r;i++){[x,y]=[-y,x];} return [x+c[0]+(p==='O'?0.5:0),y+c[1]+(p==='O'?0.5:0)];});}
    checkCollision(x,y,s) { for(const b of s) { const bx=Math.floor(x+b[0]), by=Math.floor(y+b[1]); if(bx<0||bx>=BOARD_WIDTH||by>=BOARD_HEIGHT||(by>=0&&this.board[by]?.[bx])) return true; } return false; }
    rotate(d) { if(this.gameOver||!this.player.pieceType||this.player.pieceType==='O')return; const oR=this.player.rotation, nR=(oR+d+4)%4; const oD=(this.player.pieceType==='I'?SRS_OFFSETS.I:SRS_OFFSETS.JLSTZ)[`${oR}_${nR}`]; const nS=this.getShape(this.player.pieceType,nR); for(let i=0;i<oD.length;i++){const t=oD[i];const oX=t[0],oY=-t[1]; if(!this.checkCollision(this.player.x+oX,this.player.y+oY,nS)){this.player.x+=oX;this.player.y+=oY;this.player.rotation=nR;this.lockTimer=0;this.lastMoveWasRotation=true;this.lastSrsKickIndex=i;return;}}}
    move(dx,dy,isPlayer=true) { if(this.gameOver||!this.player.pieceType)return; const s=this.getShape(this.player.pieceType,this.player.rotation); if(!this.checkCollision(this.player.x+dx,this.player.y+dy,s)){this.player.x+=dx;this.player.y+=dy;if(isPlayer){this.lockTimer=0;this.lastMoveWasRotation=false;}}}
    getGhostY() {if(!this.player.pieceType) return this.player.y; const s=this.getShape(this.player.pieceType,this.player.rotation); let y=this.player.y; while(!this.checkCollision(this.player.x,y+1,s))y++; return y;}
    
    hardDrop() {
        if (this.gameOver) return;
        const originalY = this.player.y;
        this.player.y = this.getGhostY();
        if (this.player.y > originalY) {
            this.lastMoveWasRotation = false;
        }
        this.lockPiece();
    }
    
hold() {
        if (this.gameOver || !this.canHold || this.holdDisabled) return;

        if (!this.holdPiece && this.nextQueue[0] === 'E') {
            return;
        }

        this.canHold = false;
        this.lastMoveWasRotation = false;
        if (this.holdPiece) {
            [this.player.pieceType, this.holdPiece] = [this.holdPiece, this.player.pieceType];
            this.player.rotation = 0;
            this.lockTimer = 0;
            
            this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
            const shape = this.getShape(this.player.pieceType, this.player.rotation);
            this.player.y = 19;
            if (this.checkCollision(this.player.x, this.player.y, shape)) {
                this.player.y = 18;
                if (this.checkCollision(this.player.x, this.player.y, shape)) {
                     this.gameOver = true;
                }
            }
        } else {
            this.holdPiece = this.player.pieceType;
            this.spawnNewPiece();
        }
    }

lockPiece() {
        if (!this.player.pieceType) return;
        const tspinResult = this.checkForTSpin();
        const shape = this.getShape(this.player.pieceType, this.player.rotation);

        this.specialMoveText = [];
        let moveText = '';

        for (const b of shape) { const bx = Math.floor(this.player.x + b[0]), by = Math.floor(this.player.y + b[1]); if (by >= 0) this.board[by][bx] = this.player.pieceType; }
        
        const lines = this.clearLines();
        const isPC = lines > 0 && this.board.every(row => row.every(cell => cell === null));
        
        let attack = 0;
        let isAction = false;
        let moveInfo = { name: '', isPerfectClear: false, clearedLines: lines, isB2B: false, ren: this.ren, tSpinType: tspinResult };
        
        if (isPC) {
            attack = 10;
            isAction = true;
            this.stats.perfectClear++;
            moveInfo.isPerfectClear = true;
            this.ren++;
            this.isB2B = true;
            this.specialMoveText.push("PERFECT CLEAR");
        } else if (lines > 0) {
            isAction = true; this.ren++;
            
            if (tspinResult === 'TSPIN') {
                attack = [0, 2, 4, 6][lines];
                moveText = ['', 'T-Spin Single', 'T-Spin Double', 'T-Spin Triple'][lines];
                moveInfo.name = moveText;
                if (lines === 1) this.stats.tSpinSingle++;
                if (lines === 2) this.stats.tSpinDouble++;
                if (lines === 3) this.stats.tSpinTriple++;
            } else if (tspinResult === 'MINI_TSPIN') {
                attack = [0, 0, 1, 2, 4][lines];
                moveText = ['', 'T-Spin Mini Single', 'T-Spin Mini Double'][lines] || 'T-Spin Mini';
                moveInfo.name = moveText;
                if (lines === 1) this.stats.miniTSpinSingle++;
                if (lines === 2) this.stats.miniTSpinDouble++;
            } else {
                attack = [0, 0, 1, 2, 4][lines];
                moveText = ['', 'Single', 'Double', 'Triple', 'Tetris'][lines];
                moveInfo.name = moveText;
                if (lines === 4) this.stats.tetris++;
            }
            
            const isB2BEligible = (lines === 4) || (tspinResult && lines > 0);
            if (isB2BEligible) {
                if (this.isB2B) {
                    attack++;
                    this.specialMoveText.push("Back-to-Back");
                    moveInfo.isB2B = true;
                }
                this.isB2B = true;
            } else {
                this.isB2B = false;
            }
            const renBonus = [0,0,1,1,2,2,3,3,4,4,4,4,4,5][Math.min(this.ren, 13)];
            if(renBonus > 0) {
                attack += renBonus;
            }
            if (this.ren >= 1) {
                 this.specialMoveText.push(`${this.ren} REN`);
            }
            this.stats.ren = this.ren;
        } else if (tspinResult) {
            isAction = false; 
            this.ren = -1;
            this.isB2B = false; 
            moveText = (tspinResult === 'MINI_TSPIN') ? 'T-Spin Mini' : 'T-Spin';
        }
        
        if (!isAction) {
            this.ren = -1;
            this.stats.ren = -1;
        }
        if (moveText) this.specialMoveText.push(moveText);

        if (this.opponent && attack > 0) {
            let remainingAttack = attack;
             if (isPC) {
                this.opponent.addGarbage(remainingAttack);
            } else {
                if (this.pendingGarbage > 0) { const offset = Math.min(this.pendingGarbage, remainingAttack); this.pendingGarbage -= offset; remainingAttack -= offset; }
                if (remainingAttack > 0) { for (let i=0; i < this.garbageQueue.length && remainingAttack > 0; i++) { const offset = Math.min(this.garbageQueue[i].lines, remainingAttack); this.garbageQueue[i].lines -= offset; remainingAttack -= offset; } this.garbageQueue = this.garbageQueue.filter(g => g.lines > 0); }
                if (remainingAttack > 0) { this.opponent.addGarbage(remainingAttack); }
            }
        }
        
        if (this.ruleHooks.onPieceLock && typeof this.ruleHooks.onPieceLock === 'function') {
             try {
                this.ruleHooks.onPieceLock(this.gameApi, this, moveInfo);
            } catch (e) {
                console.error("Rule error onPieceLock:", e);
                this.gameOver = true;
            }
        }
        if (this.gameOver || this.gameClear) return;


if (this.specialMoveText.length > 0) {
            this.specialMoveTextTimer = 1500;
        }

        if (this.nextQueue[0] === 'E') {    
            if (this.holdPiece) {
                this.player.pieceType = this.holdPiece;
                this.holdPiece = null;
                this.canHold = false;
                
                this.player.rotation = 0;
                this.lockTimer = 0;
                this.lastMoveWasRotation = false;
                this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
                const shape = this.getShape(this.player.pieceType, this.player.rotation);
                this.player.y = 19;
                if (this.checkCollision(this.player.x, this.player.y, shape)) {
                    this.player.y = 18;
                    if (this.checkCollision(this.player.x, this.player.y, shape)) {
                         this.gameOver = true;
                    }
                }
                return;
            } else {
                this.gameOver = true;
                return;
            }
        }

        this.lockTimer = 0;
        if (lines > 0) { this.isClearingLine = true; this.lineClearDelayTimer = gameSettings.lineClearDelay; } 
        else { this.riseGarbage(); this.spawnNewPiece(); }
    }
    
    checkForTSpin() {
        if (this.player.pieceType !== 'T' || !this.lastMoveWasRotation) return null;
        const centerX = this.player.x + TETROMINOS['T'].center[0];
        const centerY = this.player.y + TETROMINOS['T'].center[1];
        const corners = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
        let occupiedCorners = 0;
        corners.forEach(([cx, cy]) => {
            const boardX = Math.round(centerX + cx);
            const boardY = Math.round(centerY + cy);
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY < 0 || boardY >= BOARD_HEIGHT || this.board[boardY]?.[boardX]) occupiedCorners++;
        });
        if (occupiedCorners < 3) return null;
        const frontCornerDefs = { 0: [[-1, -1], [1, -1]], 1: [[1, -1], [1, 1]], 2: [[-1, 1], [1, 1]], 3: [[-1, -1], [-1, 1]] };
        const frontCorners = frontCornerDefs[this.player.rotation];
        let occupiedFrontCorners = 0;
        frontCorners.forEach(([cx, cy]) => {
            const boardX = Math.round(centerX + cx);
            const boardY = Math.round(centerY + cy);
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY < 0 || boardY >= BOARD_HEIGHT || this.board[boardY]?.[boardX]) occupiedFrontCorners++;
        });
        if (occupiedFrontCorners === 2 || this.lastSrsKickIndex === 4) return 'TSPIN';
        return 'MINI_TSPIN';
    }

    clearLines() {let cl=0; for(let y=this.board.length-1;y>=0;y--){if(this.board[y].every(c=>c!==null)){this.board.splice(y,1);cl++;}} for(let i=0;i<cl;i++){this.board.unshift(Array(BOARD_WIDTH).fill(null));} return cl;}
    addGarbage(lines) { if (this.opponent) { this.garbageQueue.push({ lines, receivedTime: performance.now() }); } }
    processGarbageQueue() { const now = performance.now(); for (let i = this.garbageQueue.length - 1; i >= 0; i--) { if (now - this.garbageQueue[i].receivedTime > gameSettings.garbageGrace) { this.pendingGarbage += this.garbageQueue[i].lines; this.garbageQueue.splice(i, 1); } } }
    
    riseGarbage() {
        if (this.pendingGarbage <= 0) return;
        
        if (this.lastGarbageHoleX === -1) {
            this.lastGarbageHoleX = Math.floor(Math.random() * BOARD_WIDTH);
        }
        
        for (let i = 0; i < this.pendingGarbage; i++) {
            if (this.board[0].some(cell => cell !== null)) {
                this.gameOver = true;
                return;
            }
            if (Math.random() < gameSettings.garbageRandomness) {
                this.lastGarbageHoleX = Math.floor(Math.random() * BOARD_WIDTH);
            }
            
            this.board.shift();
            const newRow = Array(BOARD_WIDTH).fill('G');
            newRow[this.lastGarbageHoleX] = null;
            this.board.push(newRow);
        }
        this.pendingGarbage = 0;
    }

    drawBlock(p,x,y,isGhost=false) {
        if(y<-BLOCK_SIZE)return;
        ctx.fillStyle=activeSkin[p]||'#FFF';
        ctx.globalAlpha=isGhost?0.3:1.0;
        ctx.fillRect(x,y,BLOCK_SIZE,BLOCK_SIZE);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x,y,BLOCK_SIZE,BLOCK_SIZE);
        ctx.globalAlpha=1.0;
    }

drawPiece(s,x,y,p,g) {s.forEach(b=>{const px=Math.floor(x+b[0])*BLOCK_SIZE, py=(Math.floor(y+b[1])-this.viewY)*BLOCK_SIZE; this.drawBlock(p,px,py,g);});}
    drawUI() {
        ctx.textAlign = 'center'; ctx.fillStyle = '#FFF'; ctx.font = `bold ${BLOCK_SIZE * 0.8}px "Orbitron"`;
        if (!this.holdDisabled) {
            ctx.fillText('HOLD', HOLD_AREA_WIDTH / 2, 40);
            if (this.holdPiece) { const s = this.getShape(this.holdPiece, 0); s.forEach(b => { const px = (HOLD_AREA_WIDTH / 2) - (TETROMINOS[this.holdPiece].center[0] * BLOCK_SIZE) + (b[0] * BLOCK_SIZE), py = 70 - (TETROMINOS[this.holdPiece].center[1] * BLOCK_SIZE) + (b[1] * BLOCK_SIZE); this.drawBlock(this.holdPiece, px, py); }); }
        }
        
        const meterX = PLAYFIELD_X_OFFSET - 12; const meterWidth = 8; const meterMaxHeight = BOARD_VISIBLE_HEIGHT * BLOCK_SIZE;
        const pendingHeight = Math.min(this.pendingGarbage, BOARD_VISIBLE_HEIGHT) * BLOCK_SIZE;
        if (pendingHeight > 0) { ctx.fillStyle = 'red'; ctx.fillRect(meterX, meterMaxHeight - pendingHeight + (0.5 * BLOCK_SIZE), meterWidth, pendingHeight); }
        const queuedLines = this.garbageQueue.reduce((sum, g) => sum + g.lines, 0);
        const queuedHeight = Math.min(queuedLines, BOARD_VISIBLE_HEIGHT - this.pendingGarbage) * BLOCK_SIZE;
        if (queuedHeight > 0) { ctx.fillStyle = 'yellow'; ctx.fillRect(meterX, meterMaxHeight - pendingHeight - queuedHeight + (0.5*BLOCK_SIZE), meterWidth, queuedHeight); }

        ctx.fillStyle = '#FFF'; const rX = PLAYFIELD_X_OFFSET + PLAYFIELD_WIDTH + PADDING + NEXT_AREA_WIDTH / 2;
        ctx.fillText('NEXT', rX, 40);
        for (let i = 0; i < gameSettings.maxNext; i++) {
            const pT = this.nextQueue[i]; 
            if (!pT) continue;
            if (pT === 'E') break;
            const s = this.getShape(pT, 0);
            s.forEach(b => {
                const px = rX - (TETROMINOS[pT].center[0] * BLOCK_SIZE) + (b[0] * BLOCK_SIZE);
                const py = 70 + (i * BLOCK_SIZE * 2.5) - (TETROMINOS[pT].center[1] * BLOCK_SIZE) + (b[1] * BLOCK_SIZE);
                this.drawBlock(pT, px, py);
            });
        }
    }
    
    drawSpecialMoveText() {
        if (this.specialMoveTextTimer <= 0 || this.specialMoveText.length === 0 || !gameSettings.showEffects) return;
        
        const centerX = PLAYFIELD_WIDTH / 2;
        const startY = CANVAS_HEIGHT / 2 - (this.specialMoveText.length * 18);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = 0; i < this.specialMoveText.length; i++) {
            const text = this.specialMoveText[i];
            const y = startY + (i * 35);
            
            ctx.font = `bold ${BLOCK_SIZE}px "Orbitron"`;
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;

            ctx.strokeText(text, centerX, y);
            ctx.fillText(text, centerX, y);
        }
        ctx.textBaseline = 'alphabetic';
    }

    drawMessage(t) { const cX = PLAYFIELD_WIDTH / 2; const cY = CANVAS_HEIGHT / 2; ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(0, -0.5*BLOCK_SIZE, PLAYFIELD_WIDTH, CANVAS_HEIGHT); ctx.fillStyle = '#FFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = `bold ${BLOCK_SIZE * 1.5}px "Orbitron"`; ctx.fillText(t, cX, cY); ctx.textBaseline = 'alphabetic'; }
}

function setupEditors() { ['p1', 'p2'].forEach(setupPlayerEditor); }

function setupPlayerEditor(playerId) {
    editorData[playerId].board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    const nextIcons = document.getElementById(`${playerId}-next-icons`);
    Object.keys(TETROMINOS).forEach(key => {
        const icon = document.createElement('div');
icon.className = 'mino-icon';
        icon.style.backgroundColor = activeSkin[key];
        icon.addEventListener('click', () => {
            const data = editorData[playerId];
            if (data.nextInsertionIndex === 'hold') {
                data.hold = key;
                data.nextInsertionIndex = 0;
            } else if (data.nextInsertionIndex === -1) {
                data.nextQueue.push(key);
                data.nextInsertionIndex = data.nextQueue.length;
            } else {
                data.nextQueue.splice(data.nextInsertionIndex, 0, key);
                data.nextInsertionIndex++;
            }
            updateNextQueueDisplay(playerId);
        });
        nextIcons.appendChild(icon);
    });
    
    const endIcon = document.createElement('div');
    endIcon.className = 'mino-icon';
    endIcon.style.backgroundColor = activeSkin['E'];
    endIcon.style.color = '#FFFFFF';
    endIcon.style.display = 'flex';
    endIcon.style.alignItems = 'center';
    endIcon.style.justifyContent = 'center';
    endIcon.style.fontFamily = 'var(--font-display)';
    endIcon.style.fontSize = '14px';
    endIcon.style.fontWeight = 'bold';
endIcon.textContent = 'END';
    endIcon.addEventListener('click', () => {
        const data = editorData[playerId];
        if (data.nextInsertionIndex === 'hold' || data.nextQueue.length === 0) {
            return;
        }
        const key = 'E';
        if (data.nextInsertionIndex === -1) {
            data.nextQueue.push(key);
            data.nextInsertionIndex = data.nextQueue.length;
        } else {
            data.nextQueue.splice(data.nextInsertionIndex, 0, key);
            data.nextInsertionIndex++;
        }
        updateNextQueueDisplay(playerId);
    });
    nextIcons.appendChild(endIcon);
    
     document.getElementById(`${playerId}-next-delete-left`).addEventListener('click', () => {
        const data = editorData[playerId];
        const index = data.nextInsertionIndex;
        if (index === 'hold' || (index === -1 && data.nextQueue.length === 0)) {
            return;
        }
        if (index === 0) {
            data.hold = null;
        } else if (index > 0) {
            data.nextQueue.splice(index - 1, 1);
            data.nextInsertionIndex--;
        } else { // index is -1 (end of queue)
            data.nextQueue.pop();
            data.nextInsertionIndex = data.nextQueue.length;
        }
        updateNextQueueDisplay(playerId);
    });
    document.getElementById(`${playerId}-next-clear`).addEventListener('click', () => {
        editorData[playerId].nextQueue = [];
        editorData[playerId].hold = null;
        editorData[playerId].nextInsertionIndex = 0;
        updateNextQueueDisplay(playerId);
    });
    const palette = document.getElementById(`${playerId}-palette`);

    Object.keys(EDITOR_COLORS).filter(key => key !== 'E').forEach(key => { const swatch = document.createElement('div'); swatch.className = 'color-swatch'; swatch.style.backgroundColor = key === 'EMPTY' ? '#333' : EDITOR_COLORS[key]; if (key === 'EMPTY') { swatch.style.border = '1px dashed #fff'; swatch.title = 'Eraser'; } if (key === editorData[playerId].activeColor) swatch.classList.add('active'); swatch.addEventListener('click', () => { editorData[playerId].activeColor = key; palette.querySelector('.active')?.classList.remove('active'); swatch.classList.add('active'); }); palette.appendChild(swatch); });

    const canvas = document.getElementById(`field-editor-canvas-${playerId}`);
    
    canvas.width = BOARD_WIDTH * EDITOR_BLOCK_SIZE; canvas.height = BOARD_VISIBLE_HEIGHT * EDITOR_BLOCK_SIZE;
    let isDrawing = false;
    let isEraserMode = false;

    const getCoordsFromEvent = e => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const relativeX = (clientX - rect.left) / rect.width;
        const relativeY = (clientY - rect.top) / rect.height;
        const x = Math.floor(relativeX * BOARD_WIDTH);
        const y = Math.floor(relativeY * BOARD_VISIBLE_HEIGHT);
        return { x, y };
    };
    
    const applyDraw = (x, y) => {
        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_VISIBLE_HEIGHT) {
            const boardY = y + editorData[playerId].viewY;
            if (isEraserMode) {
                editorData[playerId].board[boardY][x] = null;
            } else {
                const color = editorData[playerId].activeColor;
                editorData[playerId].board[boardY][x] = (color === 'EMPTY') ? null : color;
            }
            drawEditorField(playerId);
        }
    };

    const handleDrawStart = e => {
        e.preventDefault();
        isDrawing = true;
        const { x, y } = getCoordsFromEvent(e);
        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_VISIBLE_HEIGHT) {
            const boardY = y + editorData[playerId].viewY;
            const currentCellColor = editorData[playerId].board[boardY][x];
            const selectedColor = editorData[playerId].activeColor;
            isEraserMode = (selectedColor === 'EMPTY' || currentCellColor === selectedColor);
        }
        applyDraw(x, y);
    };

    const handleDrawMove = e => {
        if (!isDrawing) return;
        e.preventDefault();
        const { x, y } = getCoordsFromEvent(e);
        applyDraw(x, y);
    };

    const handleDrawEnd = () => {
        if (!isDrawing) return;
        isDrawing = false;
        isEraserMode = false;
    };

    canvas.addEventListener('mousedown', handleDrawStart);
    canvas.addEventListener('mouseup', handleDrawEnd);
    canvas.addEventListener('mouseleave', handleDrawEnd);
    canvas.addEventListener('mousemove', handleDrawMove);
    canvas.addEventListener('touchstart', handleDrawStart, { passive: false });
    canvas.addEventListener('touchend', handleDrawEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleDrawEnd, { passive: false });
    canvas.addEventListener('touchmove', handleDrawMove, { passive: false });
    
    document.getElementById(`${playerId}-field-shift-up`).addEventListener('click', () => shiftField(playerId, 'up'));
    document.getElementById(`${playerId}-field-shift-down`).addEventListener('click', () => shiftField(playerId, 'down'));
    document.getElementById(`${playerId}-field-clear`).addEventListener('click', () => { editorData[playerId].board.forEach(row => row.fill(null)); drawEditorField(playerId); });
    drawEditorField(playerId);
}

function shiftField(playerId, direction) {
    const board = editorData[playerId].board;
    if (direction === 'up') {
        board.shift();
        board.push(Array(BOARD_WIDTH).fill(null));
    } else {
        board.pop();
        board.unshift(Array(BOARD_WIDTH).fill(null));
    }
    drawEditorField(playerId);
}

function updateNextQueueDisplay(playerId) {
    const qd = document.getElementById(`${playerId}-next-queue`);
    qd.innerHTML = '';
    const data = editorData[playerId];

    const createGap = (index) => {
        const gap = document.createElement('div');
        gap.style.width = '8px';
        gap.style.height = '38px';
        gap.style.cursor = 'pointer';
        gap.style.display = 'flex';
        gap.style.alignItems = 'center';
        gap.style.justifyContent = 'center';
        gap.style.userSelect = 'none';
        gap.addEventListener('click', (e) => {
            e.stopPropagation();
            data.nextInsertionIndex = index;
            updateNextQueueDisplay(playerId);
        });
        if (data.nextInsertionIndex === index) {
            gap.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
            gap.style.borderRadius = '2px';
            gap.innerHTML = '<span style="color: white; font-weight: bold; line-height: 1;">|</span>';
        }
        return gap;
    };

    const holdContainer = document.createElement('div');
    holdContainer.style.display = 'flex';
    holdContainer.style.alignItems = 'center';
    holdContainer.style.gap = '5px';
    holdContainer.style.padding = '0 8px';
    holdContainer.style.borderRight = '2px solid var(--primary-color)';

    const holdSlot = document.createElement('div');
    holdSlot.className = 'mino-icon';
    holdSlot.style.width = '38px';
    holdSlot.style.height = '38px';
    holdSlot.style.cursor = 'pointer';
    holdSlot.style.boxSizing = 'border-box';
    if (data.hold) {
        holdSlot.style.backgroundColor = activeSkin[data.hold];
    } else {
        holdSlot.style.backgroundColor = 'transparent';
        holdSlot.style.border = '2px dashed #555';
    }
    if (data.nextInsertionIndex === 'hold') {
        holdSlot.style.borderColor = '#FFF';
        holdSlot.style.boxShadow = '0 0 8px #FFF';
    }
    holdSlot.addEventListener('click', (e) => {
        e.stopPropagation();
        data.nextInsertionIndex = 'hold';
        updateNextQueueDisplay(playerId);
    });
    const holdLabel = document.createElement('span');
    holdLabel.textContent = "H";
    holdLabel.style.fontFamily = 'var(--font-display)';
    holdContainer.appendChild(holdLabel);
    holdContainer.appendChild(holdSlot);
    qd.appendChild(holdContainer);
    
    const nextContainer = document.createElement('div');
    nextContainer.style.display = 'flex';
    nextContainer.style.alignItems = 'center';
    nextContainer.style.gap = '5px';
    nextContainer.style.paddingLeft = '8px';
    nextContainer.style.flexWrap = 'wrap';

   nextContainer.appendChild(createGap(0));
    data.nextQueue.forEach((key, i) => {
        const icon = document.createElement('div');
        icon.className = 'mino-icon';
        icon.style.backgroundColor = activeSkin[key];
        icon.style.width = '38px';
        icon.style.height = '38px';
        if (key === 'E') {
            icon.textContent = 'END';
            icon.style.color = 'white';
            icon.style.display = 'flex';
            icon.style.alignItems = 'center';
            icon.style.justifyContent = 'center';
            icon.style.fontFamily = 'var(--font-display)';
            icon.style.fontSize = '12px';
            icon.style.fontWeight = 'bold';
        }
        nextContainer.appendChild(icon);
        nextContainer.appendChild(createGap(i + 1));
    });
    qd.appendChild(nextContainer);

    qd.onclick = (e) => {
        if (e.target === qd || e.target === nextContainer) {
            data.nextInsertionIndex = data.nextQueue.length;
            updateNextQueueDisplay(playerId);
        }
    };
}

function drawEditorField(playerId) {
    const canvas = document.getElementById(`field-editor-canvas-${playerId}`),
        ctx = canvas.getContext('2d'),
        data = editorData[playerId];
    ctx.fillStyle = '#0f0f18';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#444'; 
    ctx.lineWidth = 1;
    for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            const pieceType = data.board[y + data.viewY]?.[x];
            if (pieceType) {
                ctx.fillStyle = activeSkin[pieceType];
                ctx.fillRect(x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
            }
            ctx.strokeRect(x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
        }
    }
}

function bindKey(binding) {
    if (!isBindingKey || !bindingPlayer || !bindingAction) return;
    
    keyBindings[bindingPlayer][bindingAction] = binding;
    isBindingKey = false;
    bindingAction = null;
    const tabToReopen = bindingPlayer === 'p1' ? 'p1-keys' : 'p2-keys';
    openUnifiedSettingsModal(tabToReopen);
}

function loadKeyBindings() {
    try {
        const savedBindings = JSON.parse(localStorage.getItem('tetrisKeyBindings'));
        if (savedBindings) {
            if (savedBindings.p1) Object.assign(keyBindings.p1, savedBindings.p1);
            if (savedBindings.p2) Object.assign(keyBindings.p2, savedBindings.p2);
        }
    } catch (e) { console.error("Failed to load key bindings from localStorage:", e); }
}

function saveGameSettings() {
    try {
        localStorage.setItem('tetrisGameSettings', JSON.stringify(gameSettings));
    } catch (e) { console.error("Failed to save game settings to localStorage:", e); }
}

function loadGameSettings() {
    try {
        const saved = localStorage.getItem('tetrisGameSettings');
        if (saved) {
            const parsed = JSON.parse(saved);
            Object.assign(gameSettings, parsed);
        }
    } catch(e) { console.error('Failed to load settings from localStorage:', e); }
}

function populateGeneralSettingsTab() {
    const list = document.getElementById('settings-list');
    list.innerHTML = '';
    const settingDetails = {
        das: { label: 'DAS (ms)', min: 0, max: 500, step: 10 },
        arr: { label: 'ARR (ms)', min: 0, max: 100, step: 1 },
        sdf: { label: 'SDF (ms)', min: 0, max: 100, step: 1 },
        lineClearDelay: { label: 'Line Clear Delay (ms)', min: 0, max: 2000, step: 50 },
        gravity: { label: 'Gravity Interval (ms)', min: 0, max: 9999999, step: 50 },
        lockDelay: { label: 'Lock Delay (ms)', min: 0, max: 9999999, step: 50 },
        maxNext: { label: 'Max NEXT Display', min: 1, max: 8, step: 1 },
        garbageGrace: { label: 'Garbage Grace (ms)', min: 0, max: 5000, step: 100 },
        garbageRandomness: { label: 'Garbage Hole Randomness (%)', min: 0, max: 100, step: 1 }
    };
    Object.keys(settingDetails).forEach(key => {
        const item = document.createElement('div'); item.className = 'setting-item';
        const label = document.createElement('span'); label.textContent = settingDetails[key].label;
        const input = document.createElement('input'); input.type = 'number';
        Object.assign(input, settingDetails[key]);
        let currentValue = gameSettings[key];
        if (key === 'garbageRandomness') currentValue *= 100;
        input.value = currentValue;
        input.onchange = e => {
            let val = parseFloat(e.target.value);
            if (key === 'garbageRandomness') gameSettings[key] = Math.max(0, Math.min(100, val)) / 100;
            else gameSettings[key] = Math.max(settingDetails[key].min, Math.min(settingDetails[key].max, val));
        };
        item.append(label, input); list.appendChild(item);
    });
    
    const checkboxSettings = { showEffects: 'エフェクトを表示する', touchControlsEnabled: 'タッチ操作を有効にする (P1)' };
    Object.entries(checkboxSettings).forEach(([key, text], index) => {
        const item = document.createElement('div'); item.className = 'setting-item';
        if (index === 0) { item.style.cssText = 'margin-top:20px; border-top:1px solid var(--primary-color); padding-top:15px;'; }
        const label = document.createElement('label'); const checkbox = document.createElement('input');
        checkbox.type = 'checkbox'; checkbox.id = `setting-${key}`; checkbox.checked = !!gameSettings[key];
        checkbox.onchange = e => { gameSettings[key] = e.target.checked; };
        const span = document.createElement('span'); span.textContent = text;
        label.append(checkbox, span); item.appendChild(label); list.appendChild(item);
    });
}

function populateKeyConfigTab(playerId) {
    const list = document.getElementById(`${playerId}-key-config-list`);
    list.innerHTML = ''; 
    Object.keys(keyBindings[playerId]).forEach(action => {
        const item = document.createElement('div'); item.className = 'key-config-item';
        const label = document.createElement('span'); label.textContent = keyActionLabels[action];
        const btn = document.createElement('button'); btn.className = 'button';
        btn.textContent = keyBindings[playerId][action].label;
        btn.onclick = () => {
            isBindingKey = true; bindingPlayer = playerId; bindingAction = action;
            btn.textContent = '入力待機中...';
            list.querySelectorAll('button').forEach(b => { if (b !== btn) b.disabled = true; });
        };
        item.appendChild(label); item.appendChild(btn); list.appendChild(item);
    });
}



function openUnifiedSettingsModal(initialTab = 'general') {
    const modal = document.getElementById('settings-modal');
    
    const p2TabBtn = document.getElementById('p2-keys-tab-btn');
    if (gameMode === '2P') {
        p2TabBtn.style.display = 'block';
    } else {
        p2TabBtn.style.display = 'none';
        if (initialTab === 'p2-keys') initialTab = 'general';
    }

    populateGeneralSettingsTab();
    populateKeyConfigTab('p1');
    if (gameMode === '2P') {
        populateKeyConfigTab('p2');
    }

    const tabs = modal.querySelectorAll('.tab-button');
    const contents = modal.querySelectorAll('.tab-content');
    
    function switchTab(tabName) {
        tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.tab === tabName));
        contents.forEach(content => content.classList.toggle('active', content.id === `tab-content-${tabName}`));
    }
    
    tabs.forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });

    switchTab(initialTab);
    modal.style.display = 'flex';
}

function startScanProcess(file, playerId) { const reader = new FileReader(); reader.onload = e => { scanState.image = new Image(); scanState.image.onload = () => { scanState.targetPlayerId = playerId; scanState.bottomLeft = null; scanState.topRight = null; gameState = 'SCAN_BL'; document.getElementById('editor-container').style.display = 'none'; document.getElementById('game-container').style.display = 'block'; document.getElementById('scan-controls').style.display = 'flex'; 
const ar = scanState.image.naturalWidth / scanState.image.naturalHeight; const displayMaxWidth = window.innerWidth * 0.9; const displayMaxHeight = window.innerHeight * 0.8; let displayWidth = displayMaxWidth; let displayHeight = displayWidth / ar; if (displayHeight > displayMaxHeight) { displayHeight = displayMaxHeight; displayWidth = displayHeight * ar; } const canvasWidth = Math.min(2048, scanState.image.naturalWidth); mainCanvas.width = canvasWidth; mainCanvas.height = canvasWidth / ar; mainCanvas.style.width = `${displayWidth}px`; mainCanvas.style.height = `${displayHeight}px`; updateScanUI(); setTimeout(updateScale, 0);}; scanState.image.src = e.target.result; }; reader.readAsDataURL(file); }
function endScanProcess() { gameState = 'EDITING'; scanState.image = null; mainCanvas.style.width = ''; mainCanvas.style.height = ''; document.getElementById('editor-container').style.display = 'flex'; document.getElementById('game-container').style.display = 'none'; document.getElementById('scan-controls').style.display = 'none'; ['p1', 'p2'].forEach(drawEditorField); setTimeout(updateScale, 0); }
function updateScanUI() { const instructions = document.getElementById('scan-instructions'), confirmBtn = document.getElementById('scanConfirmBtn'); instructions.style.display = 'block'; mainCanvas.style.cursor = 'crosshair'; if (gameState === 'SCAN_BL') { instructions.textContent = '画像の盤面の「左下」をクリック'; confirmBtn.style.visibility = scanState.bottomLeft ? 'visible' : 'hidden'; } else if (gameState === 'SCAN_TR') { instructions.textContent = '「右上」をクリック →「読込開始」'; confirmBtn.style.visibility = scanState.topRight ? 'visible' : 'hidden'; if (scanState.topRight) confirmBtn.textContent = '読込開始'; else confirmBtn.textContent = '次へ'; } }
function drawScanner() { if (!scanState.image) return; ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); ctx.drawImage(scanState.image, 0, 0, mainCanvas.width, mainCanvas.height); if (scanState.bottomLeft) { ctx.fillStyle = 'lime'; ctx.beginPath(); ctx.arc(scanState.bottomLeft.x, scanState.bottomLeft.y, 10, 0, Math.PI * 2); ctx.fill(); } if (scanState.topRight) { const {x: blx, y: bly} = scanState.bottomLeft, {x: trx, y: try_} = scanState.topRight; ctx.strokeStyle = 'fuchsia'; ctx.lineWidth = 4; ctx.strokeRect(blx, try_, trx - blx, bly - try_); } }
function processAndLoadBoard() { const tempC = document.createElement('canvas'); tempC.width = scanState.image.naturalWidth; tempC.height = scanState.image.naturalHeight; const tempCtx = tempC.getContext('2d', { willReadFrequently: true }); tempCtx.drawImage(scanState.image, 0, 0); const sX = scanState.image.naturalWidth / mainCanvas.width, sY = scanState.image.naturalHeight / mainCanvas.height; const iBL = { x: scanState.bottomLeft.x*sX, y: scanState.bottomLeft.y*sY }, iTR = { x: scanState.topRight.x*sX, y: scanState.topRight.y*sY }; const bW_px = iTR.x - iBL.x, bH_px = iBL.y - iTR.y, blW_px = bW_px/BOARD_WIDTH, blH_px = bH_px/BOARD_VISIBLE_HEIGHT; const targetBoard = editorData[scanState.targetPlayerId].board; targetBoard.forEach(row => row.fill(null)); for (let r = 0; r < BOARD_VISIBLE_HEIGHT; r++) { for (let c = 0; c < BOARD_WIDTH; c++) { const cX = iBL.x + (c+0.5)*blW_px, cY = iTR.y + (r+0.5)*blH_px; const sampleSize = Math.max(1, Math.floor(blW_px * 0.25)); const iD = tempCtx.getImageData(cX-sampleSize/2, cY-sampleSize/2, sampleSize, sampleSize).data; let avgR=0, avgG=0, avgB=0; for(let i=0; i<iD.length; i+=4){ avgR+=iD[i]; avgG+=iD[i+1]; avgB+=iD[i+2]; } const pCount = iD.length/4; avgR/=pCount; avgG/=pCount; avgB/=pCount; targetBoard[BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT + r][c] = findClosestColor(avgR, avgG, avgB); } } endScanProcess(); }

function findClosestColor(r, g, b) {
    const inputColor = { r, g, b };
    const colorDistanceSq = (c1, c2) => {
        return Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
    };
    for (const nullColor of PARSED_SCAN_COLORS.NULL) {
        if (colorDistanceSq(inputColor, nullColor) < 6000) {
            return null;
        }
    }
    for (const gColor of PARSED_SCAN_COLORS.G) {
        if (colorDistanceSq(inputColor, gColor) < 10000) {
            return 'G';
        }
    }
    let minDistance = Infinity;
    let closestKey = null;
    const minoKeys = Object.keys(PARSED_SCAN_COLORS).filter(k => k !== 'NULL' && k !== 'G');
    for (const key of minoKeys) {
        for (const targetColor of PARSED_SCAN_COLORS[key]) {
            const distance = colorDistanceSq(inputColor, targetColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestKey = key;
            }
        }
    }
    return (minDistance > 25000) ? null : closestKey;
}

function getAverageColorNonBlack(ctx, cx, cy, radius) {
    const startX = Math.floor(cx - radius);
    const startY = Math.floor(cy - radius);
    const diameter = Math.ceil(radius * 2);
    if (startX < 0 || startY < 0 || startX + diameter > ctx.canvas.width || startY + diameter > ctx.canvas.height) {
        return { r: 0, g: 0, b: 0 };
    }
    const imageData = ctx.getImageData(startX, startY, diameter, diameter).data;
    
    let totalR = 0, totalG = 0, totalB = 0, count = 0;
    const radiusSq = radius * radius;
    const blackThreshold = 50; 

    for (let y = 0; y < diameter; y++) {
        for (let x = 0; x < diameter; x++) {
            const dx = x - radius;
            const dy = y - radius;
            
            if (dx * dx + dy * dy <= radiusSq) {
                const i = (y * diameter + x) * 4;
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                
                if (r > blackThreshold || g > blackThreshold || b > blackThreshold) {
                    totalR += r;
                    totalG += g;
                    totalB += b;
                    count++;
                }
            }
        }
    }
    
    if (count === 0) {
        return { r: 0, g: 0, b: 0 };
    }
    
    return {
        r: totalR / count,
        g: totalG / count,
        b: totalB / count
    };
}

function findClosestMinoOnly(r, g, b) {
    const inputColor = { r, g, b };
    const colorDistanceSq = (c1, c2) => {
        return Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
    };

    let minDistance = Infinity;
    let closestKey = 'I'; 
    
    const minoKeys = Object.keys(PARSED_SCAN_COLORS).filter(k => k !== 'NULL' && k !== 'G');
    
    for (const key of minoKeys) {
        for (const targetColor of PARSED_SCAN_COLORS[key]) {
            const distance = colorDistanceSq(inputColor, targetColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestKey = key;
            }
        }
    }
    return closestKey;
}

function processPptImage(file) {
    const reader = new FileReader();
    reader.onload = e => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            let sx = 0, sy = 0, sWidth = img.naturalWidth, sHeight = img.naturalHeight;
            const originalAspectRatio = sWidth / sHeight;
            const targetAspectRatio = 16 / 9;

            if (originalAspectRatio > targetAspectRatio) {
                const newWidth = sHeight * targetAspectRatio;
                sx = (sWidth - newWidth) / 2;
                sWidth = newWidth;
            } else if (originalAspectRatio < targetAspectRatio) {
                const newHeight = sWidth / targetAspectRatio;
                sy = (sHeight - newHeight) / 2;
                sHeight = newHeight;
            }
            
            canvas.width = sWidth;
            canvas.height = sHeight;
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

            loadBoardFromPptCanvas(canvas, 'p1');
            if (gameMode === '2P') {
                loadBoardFromPptCanvas(canvas, 'p2');
            }
            
            drawEditorField('p1');
            if (gameMode === '2P') {
                drawEditorField('p2');
            }
            updateNextQueueDisplay('p1');
            if (gameMode === '2P') {
                updateNextQueueDisplay('p2');
            }
            //alert('ぷよテト画像から盤面とネクストを読み込みました。');
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function loadBoardFromPptCanvas(sourceCanvas, playerId) {
    const ctx = sourceCanvas.getContext('2d', { willReadFrequently: true });
    const width = sourceCanvas.width;
    const scale = width / 1280;

    // --- Board Recognition ---
    const baseBoardCoords = {
        p1: { x1: 205, y1: 106, x2: 445, y2: 596 },
        p2: { x1: 835, y1: 106, x2: 1075, y2: 596 }
    };
    const boardCoords = baseBoardCoords[playerId];
    const boardTopLeft = { x: boardCoords.x1 * scale, y: boardCoords.y1 * scale };
    const boardWidthPx = (boardCoords.x2 - boardCoords.x1) * scale;
    const boardHeightPx = (boardCoords.y2 - boardCoords.y1) * scale;
    const blockWidthPx = boardWidthPx / BOARD_WIDTH;
    const blockHeightPx = boardHeightPx / BOARD_VISIBLE_HEIGHT;
    
    const targetBoard = editorData[playerId].board;
    targetBoard.forEach(row => row.fill(null));

    for (let r = 0; r < BOARD_VISIBLE_HEIGHT; r++) {
        for (let c = 0; c < BOARD_WIDTH; c++) {
            const sampleX = boardTopLeft.x + (c + 0.5) * blockWidthPx;
            const sampleY = boardTopLeft.y + (r + 0.5) * blockHeightPx;
            const sampleSize = Math.max(1, Math.floor(blockWidthPx * 0.25));
            const imageData = ctx.getImageData(sampleX - sampleSize / 2, sampleY - sampleSize / 2, sampleSize, sampleSize).data;
            
            let avgR = 0, avgG = 0, avgB = 0;
            for (let i = 0; i < imageData.length; i += 4) {
                avgR += imageData[i];
                avgG += imageData[i+1];
                avgB += imageData[i+2];
            }
            const pixelCount = imageData.length / 4;
            avgR /= pixelCount;
            avgG /= pixelCount;
            avgB /= pixelCount;
            
            targetBoard[BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT + r][c] = findClosestColor(avgR, avgG, avgB);
        }
    }

    // --- Post-processing: Clean up misidentified garbage ---
    let firstNonGarbageRowFromBottom = -1;
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (!targetBoard[y].includes('G')) {
            firstNonGarbageRowFromBottom = y;
            break;
        }
    }
    if (firstNonGarbageRowFromBottom !== -1) {
        for (let y = firstNonGarbageRowFromBottom - 1; y >= 0; y--) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                if (targetBoard[y][x] === 'G') {
                    targetBoard[y][x] = null;
                }
            }
        }
    }

// --- Post-processing: Clean up floating blocks ---
    let firstEmptyRowFromBottom = -1;
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (targetBoard[y].every(cell => cell === null)) {
            firstEmptyRowFromBottom = y;
            break;
        }
    }
    
    const deletedMinoColors = []; // 削除されたミノの色を記録する配列を追加

    if (firstEmptyRowFromBottom !== -1) {
        const seventeenthRowFromBottomIndex = BOARD_HEIGHT - 18;
        for (let y = firstEmptyRowFromBottom - 1; y >= 0; y--) {
            if (y <= seventeenthRowFromBottomIndex) {
                 // 行を単にnullで埋めるのではなく、各セルをチェックする
                 for (let x = 0; x < BOARD_WIDTH; x++) {
                    const piece = targetBoard[y][x];
                    if (piece && piece !== 'G') {
                        deletedMinoColors.push(piece); // おじゃま以外なら色を記録
                    }
                    targetBoard[y][x] = null; // セルを空にする
                 }
            }
        }
    }

    // --- Next Queue Recognition ---
    const nextCoordsP1 = [ { x: 160, y: 155 }, { x: 500, y: 122 }, { x: 500, y: 175 }, { x: 500, y: 225 }, { x: 500, y: 275 }, { x: 500, y: 325 } ];
    const nextCoordsP2 = [ { x: 790, y: 155 }, { x: 1130, y: 122 }, { x: 1130, y: 175 }, { x: 1130, y: 225 }, { x: 1130, y: 275 }, { x: 1130, y: 325 } ];
    const nextCoords = (playerId === 'p1') ? nextCoordsP1 : nextCoordsP2;
    const radius = 5 * scale;
    const newNextQueue = [];
    editorData[playerId].hold = null; // 最初にホールドをリセット

    for (let i = 0; i < nextCoords.length; i++) {
        const coord = nextCoords[i];
        const sampleX = coord.x * scale;
        const sampleY = coord.y * scale;
        
        const avgColor = getAverageColorNonBlack(ctx, sampleX, sampleY, radius);

        // 0番目の座標はホールド
        if (i === 0) {
            const foundHoldMino = findClosestColor(avgColor.r, avgColor.g, avgColor.b);
            editorData[playerId].hold = foundHoldMino;
        // 1番目以降の座標はネクスト
        } else {
            // 最初のネクストミノの場所が黒ければ、キューは空と判断して中断
            const isBlack = avgColor.r < 50 && avgColor.g < 50 && avgColor.b < 50;
            if (i === 1 && isBlack) {
                break;
            }
            
            const foundMino = findClosestMinoOnly(avgColor.r, avgColor.g, avgColor.b);
            if (foundMino) {
                newNextQueue.push(foundMino);
            }
        }
    }
    
    // 削除されたミノの色をチェックし、条件を満たせばNEXTキューに追加
    if (deletedMinoColors.length > 0 && deletedMinoColors.every(color => color === deletedMinoColors[0])) {
        const singleMinoType = deletedMinoColors[0];
        // ホールドは分離されたので、このミノはネクストキューの先頭に追加する
        newNextQueue.unshift(singleMinoType);
    }

    editorData[playerId].nextQueue = newNextQueue;
}

function boardToString(board) {
    return board.map(row => 
        row.map(cell => cell === null ? '_' : cell).join('')
    ).join('');
}

function stringToBoard(str) {
    const board = [];
    if (!str || str.length !== BOARD_WIDTH * BOARD_HEIGHT) {
        console.error('Invalid board string length. Returning empty board.');
        return Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    }
    for (let i = 0; i < BOARD_HEIGHT; i++) {
        const rowStr = str.substring(i * BOARD_WIDTH, (i + 1) * BOARD_WIDTH);
        const row = rowStr.split('').map(char => (char === '_') ? null : char);
        board.push(row);
    }
    return board;
}

let autoStartParams = { ss: false, nh: false, hb: false };

function getGameStateForExport(options = {}) {
    const p1Data = { ...editorData.p1, nextQueue: [...editorData.p1.nextQueue] };
    const p2Data = gameMode === '2P' ? { ...editorData.p2, nextQueue: [...editorData.p2.nextQueue] } : null;
    if (options.noHold) {
        if (p1Data.hold) { p1Data.nextQueue.unshift(p1Data.hold); p1Data.hold = null; }
        if (p2Data && p2Data.hold) { p2Data.nextQueue.unshift(p2Data.hold); p2Data.hold = null; }
    }

    const data = {
        v: 2, m: gameMode,
        p1: { b: boardToString(p1Data.board), n: p1Data.nextQueue.join(''), h: p1Data.hold || '' }
    };
if (gameMode === '2P') {
        data.p2 = { b: boardToString(p2Data.board), n: p2Data.nextQueue.join(''), h: p2Data.hold || '' };
    }
    if (options.startSim) data.ss = 1;
    if (options.noHold) data.nh = 1;
    if (options.hideBack) data.hb = 1;
    
    if (editorData.rule.description) data.rd = editorData.rule.description;
    if (editorData.rule.code) data.rc = editorData.rule.code;

    return data;
}
function applyGameState(data) {
    try {
        if (!data || (data.v !== 1 && data.v !== 2)) {
            alert('無効または非対応のデータです。'); return false;
        }
        gameMode = data.m || '1P';
        document.getElementById('mode-1p').classList.toggle('active', gameMode === '1P');
        document.getElementById('mode-2p').classList.toggle('active', gameMode === '2P');
        document.getElementById('p2-editor-col').style.display = (gameMode === '2P') ? 'flex' : 'none';
        
        editorData.rule.description = data.rd || '';
        editorData.rule.code = data.rc || '';

        if (data.p1) {
            editorData.p1.board = stringToBoard(data.p1.b);
            editorData.p1.nextQueue = data.p1.n ? data.p1.n.split('') : [];
            editorData.p1.hold = data.p1.h || null;
            drawEditorField('p1'); updateNextQueueDisplay('p1');
        }
        if (gameMode === '2P' && data.p2) {
            editorData.p2.board = stringToBoard(data.p2.b);
            editorData.p2.nextQueue = data.p2.n ? data.p2.n.split('') : [];
            editorData.p2.hold = data.p2.h || null;
            drawEditorField('p2'); updateNextQueueDisplay('p2');
        } else if (gameMode !== '2P') {
            editorData.p2.board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
            editorData.p2.nextQueue = [];
            editorData.p2.hold = null;
            if (document.getElementById('p2-editor-col').style.display !== 'none') {
                 drawEditorField('p2'); updateNextQueueDisplay('p2');
            }
        }
        updateScale(); return true;
    } catch (e) {
        console.error('Failed to apply game state:', e); alert('データの読み込みに失敗しました。'); return false;
    }
}

function loadStateFromURL() {
    if (window.location.hash) {
        try {
            const base64Data = window.location.hash.substring(1);
            const binaryString = atob(base64Data);
            const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
            const jsonString = new TextDecoder().decode(bytes);
            const data = JSON.parse(jsonString);

            autoStartParams.ss = !!data.ss;
            autoStartParams.nh = !!data.nh;
            autoStartParams.hb = !!data.hb;

            if (applyGameState(data)) {
                //alert('URLから盤面を読み込みました。');
                if (autoStartParams.ss) {
                    setTimeout(() => document.getElementById('startGameBtn').click(), 100);
                }
            }
            history.pushState("", document.title, window.location.pathname + window.location.search);
        } catch (e) {
            console.error('Failed to load state from URL hash:', e);
            alert('URLからのデータ読み込みに失敗しました。');
            history.pushState("", document.title, window.location.pathname + window.location.search);
        }
    }
}


function generateAndDisplayLink(options = {}) {
    const stateData = getGameStateForExport(options);
    const jsonString = JSON.stringify(stateData);
    const uint8Array = new TextEncoder().encode(jsonString);
    const base64Data = btoa(String.fromCharCode.apply(null, uint8Array));
    const url = new URL(window.location);
    url.hash = base64Data;
    document.getElementById('share-link-input').value = url.href;
}

function openShareModal() {
    generateAndDisplayLink();
    document.getElementById('advanced-link-options').style.display = 'none';
    document.getElementById('share-modal').style.display = 'flex';
}
function pollGamepads() {
    const rawPads = navigator.getGamepads();
    if (!rawPads) return;

    for (let i = 0; i < rawPads.length; i++) {
        const pad = rawPads[i];
        if (!pad) {
            delete gamepads[i];
            delete prevGamepads[i];
            continue;
        };

        gamepads[i] = { buttons: pad.buttons.map(b => b.pressed), axes: [...pad.axes] };

        if (isBindingKey) {
            if (prevGamepads[i]) {
                for (let j = 0; j < pad.buttons.length; j++) {
                    if (gamepads[i].buttons[j] && !prevGamepads[i].buttons[j]) {
                        bindKey({ type: 'pad_button', value: j, label: `Pad${i}-Btn${j}` });
                        return;
                    }
                }
                for (let j = 0; j < pad.axes.length; j++) {
                    const val = gamepads[i].axes[j], prevVal = prevGamepads[i].axes[j];
                    if (Math.abs(val) > AXIS_THRESHOLD && Math.abs(prevVal) < AXIS_THRESHOLD) {
                        const dir = val > 0 ? '+' : '-';
                        bindKey({ type: 'pad_axis', value: `${j}${dir}`, label: `Pad${i}-Axis${j}${dir}` });
                        return;
                    }
                }
            }
        } else if (gameState === 'PLAYING') {
             players.forEach(p => {
                if(p.padIndex === i) {
                    Object.keys(p.keyBindings).forEach(action => {
                        const binding = p.keyBindings[action];
                        if (binding.type === 'pad_button' && gamepads[i].buttons[binding.value] && !prevGamepads[i]?.buttons[binding.value]) {
                           p.handlePress(action);
                        }
                    });
                }
            });
        }
    }
    Object.keys(gamepads).forEach(i => {
        prevGamepads[i] = { buttons: [...gamepads[i].buttons], axes: [...gamepads[i].axes] };
    });
}


function gameLoop(currentTime) {
    if (!ctx) return;
    pollGamepads();
    const dt = currentTime - lastTime;
    lastTime = currentTime;
    ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    if (gameState === 'PLAYING') {
        players.forEach(p => p.update(dt || 0));
        players.forEach(p => p.draw());
    } else if (gameState.startsWith('SCAN')) {
        drawScanner();
    }
    requestAnimationFrame(gameLoop);
}

const mainContainer = document.querySelector('.main-container');

function updateScale() {
    if (gameState.startsWith('SCAN')) {
        mainContainer.style.transform = '';
        return;
    }

    mainContainer.style.transform = 'none';

    const rect = mainContainer.getBoundingClientRect();
    const nativeWidth = rect.width;
    const nativeHeight = rect.height;
    
    if (nativeWidth === 0 || nativeHeight === 0) {
        mainContainer.style.transform = '';
        return;
    }

    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    const scale = Math.min(
        viewportWidth / nativeWidth,
        viewportHeight / nativeHeight
    ) * 0.98;

    mainContainer.style.transform = `scale(${scale})`;
}

document.addEventListener('DOMContentLoaded', () => {
    mainCanvas = document.getElementById('mainCanvas'); ctx = mainCanvas.getContext('2d');
    
    virtualController.init();

    loadKeyBindings();
    loadGameSettings();

    document.getElementById('shareBtn').addEventListener('click', openShareModal);
    document.getElementById('share-close').addEventListener('click', () => {
        document.getElementById('share-modal').style.display = 'none';
    });

    document.getElementById('ruleBtn').addEventListener('click', () => {
        document.getElementById('rule-description-input').value = editorData.rule.description;
        document.getElementById('rule-code-input').value = editorData.rule.code;
        document.getElementById('rule-modal').style.display = 'flex';
    });
    document.getElementById('rule-save-close').addEventListener('click', () => {
        editorData.rule.description = document.getElementById('rule-description-input').value;
        editorData.rule.code = document.getElementById('rule-code-input').value;
        document.getElementById('rule-modal').style.display = 'none';
    });
    document.getElementById('rule-close').addEventListener('click', () => {
        document.getElementById('rule-modal').style.display = 'none';
    });
    
    document.getElementById('copy-link-btn').addEventListener('click', () => {
        const input = document.getElementById('share-link-input');
        input.select();
        navigator.clipboard.writeText(input.value)
            .then(() => alert('共有リンクをクリップボードにコピーしました！'))
            .catch(err => alert('コピーに失敗しました: ' + err));
    });
    


        document.getElementById('import-from-data-btn').addEventListener('click', async () => {
        try {
            const text = await navigator.clipboard.readText();
            if (!text) {
                alert('クリップボードが空です。');
                return;
            }

            let data;

                if (text.startsWith('http') && text.includes('#')) {
                const base64Data = text.substring(text.indexOf('#') + 1);
                const binaryString = atob(base64Data);
                const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
                const jsonString = new TextDecoder().decode(bytes);
                data = JSON.parse(jsonString);
            } else {
                data = JSON.parse(text);
            }
            
            if(applyGameState(data)) {
                 alert('クリップボードから盤面を読み込みました。');
                 document.getElementById('share-modal').style.display = 'none';
            }

        } catch (e) {
            alert('クリップボードのデータが無効か、読み込みに失敗しました。');
            console.error('Failed to import from clipboard:', e);
        }
    });


    document.getElementById('mode-1p').addEventListener('click', () => { 
        gameMode = '1P'; 
        document.getElementById('mode-1p').classList.add('active'); 
        document.getElementById('mode-2p').classList.remove('active'); 
        document.getElementById('p2-editor-col').style.display = 'none'; 
        setTimeout(updateScale, 0);
    });
    document.getElementById('mode-2p').addEventListener('click', () => { 
        gameMode = '2P'; 
        document.getElementById('mode-2p').classList.add('active'); 
        document.getElementById('mode-1p').classList.remove('active'); 
        document.getElementById('p2-editor-col').style.display = 'flex';
        setTimeout(updateScale, 0);
    });
    document.getElementById('advanced-link-btn').addEventListener('click', () => {
        document.getElementById('advanced-link-options').style.display = 'block';
    });
    
    const startSimCheckbox = document.getElementById('start-sim-checkbox');
    const hideBackCheckbox = document.getElementById('hide-back-btn-checkbox');
    startSimCheckbox.addEventListener('change', () => {
        if (startSimCheckbox.checked) {
            hideBackCheckbox.disabled = false;
        } else {
            hideBackCheckbox.disabled = true;
            hideBackCheckbox.checked = false;
        }
    });

    document.getElementById('generate-advanced-link-btn').addEventListener('click', () => {
        generateAndDisplayLink({
            startSim: document.getElementById('start-sim-checkbox').checked,
            noHold: document.getElementById('no-hold-checkbox').checked,
            hideBack: document.getElementById('hide-back-btn-checkbox').checked
        });
    });

document.getElementById('startGameBtn').addEventListener('click', () => {
        let currentRunSettings = { ...gameSettings };
        let userFunctions = {};
        let startTime = performance.now();
        
        if (editorData.rule.code) {
            try {
                const initApi = {
                    forceSetting: (key, value) => {
                        if (key in currentRunSettings) {
                            currentRunSettings[key] = value;
                        } else {
                            console.warn(`Rule tried to force unknown setting: ${key}`);
                        }
                    }
                };
                
                const combinedCode = editorData.rule.code + 
                    `\nreturn { 
                        onInit: typeof onInit === 'function' ? onInit : undefined,
                        onPieceLock: typeof onPieceLock === 'function' ? onPieceLock : undefined,
                        onUpdate: typeof onUpdate === 'function' ? onUpdate : undefined
                    };`;

                const ruleScript = new Function('api', combinedCode);
                const returnedFuncs = ruleScript(initApi);

                if (returnedFuncs.onInit) {
                    returnedFuncs.onInit(initApi);
                }
                userFunctions = returnedFuncs;

            } catch (e) {
                alert('カスタムルールコードの実行中にエラーが発生しました:\n' + e.message);
                console.error("Custom rule script error:", e);
                return;
            }
        }
        
        const originalSettingsBeforeRun = { ...gameSettings };
        Object.assign(gameSettings, currentRunSettings);

        gameState = 'PLAYING'; 
        document.getElementById('editor-container').style.display = 'none'; 
        document.getElementById('game-container').style.display = 'block';
        document.getElementById('scan-controls').style.display = 'none';
        document.getElementById('game-controls').style.display = 'flex';
        
        const ruleDescDisplay = document.getElementById('rule-description-display');
        if (editorData.rule.description) {
            ruleDescDisplay.innerText = editorData.rule.description;
            ruleDescDisplay.style.display = 'block';
            const p1OffsetX = 0;
            const leftPos = p1OffsetX + PADDING;
            const topPos = 160; 
            ruleDescDisplay.style.left = `${leftPos}px`;
            ruleDescDisplay.style.top = `${topPos}px`;
            ruleDescDisplay.style.maxWidth = `${HOLD_AREA_WIDTH - PADDING}px`;
        } else {
            ruleDescDisplay.style.display = 'none';
        }
        
        if (autoStartParams.hb) {
            document.getElementById('backToEditorBtn').style.display = 'none';
        } else {
            document.getElementById('backToEditorBtn').style.display = '';
        }

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        players = [];
        const createAndSetupPlayer = (id, offsetX, bindings, padIndex) => {
            const player = new Player(id, offsetX, bindings, padIndex);
            player.holdDisabled = autoStartParams.nh;
            player.ruleHooks = userFunctions;
            return player;
        };

        if (gameMode === '1P') {
            mainCanvas.width = PLAYER_CANVAS_WIDTH * RESOLUTION_SCALE; 
            mainCanvas.height = CANVAS_HEIGHT * RESOLUTION_SCALE;
            mainCanvas.style.width = PLAYER_CANVAS_WIDTH + 'px';
            mainCanvas.style.height = CANVAS_HEIGHT + 'px';
            players.push(createAndSetupPlayer('1', 0, keyBindings.p1, 0));
        }
        else {
            const totalWidth = PLAYER_CANVAS_WIDTH * 2;
            mainCanvas.width = totalWidth * RESOLUTION_SCALE; 
            mainCanvas.height = CANVAS_HEIGHT * RESOLUTION_SCALE;
            mainCanvas.style.width = totalWidth + 'px';
            mainCanvas.style.height = CANVAS_HEIGHT + 'px';
            const p1 = createAndSetupPlayer('1', 0, keyBindings.p1, 0);
            const p2 = createAndSetupPlayer('2', PLAYER_CANVAS_WIDTH, keyBindings.p2, 1);
            p1.opponent = p2; 
            p2.opponent = p1;
            players.push(p1, p2);
        }

　　　　　const createPlayerProxy = (player) => {
            if (!player) return null;
            return {
                get stats() { return player.stats; },
                board: {
                    hasBlock: (x, y) => {
                        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT) return true;
                        return player.board[y][x] !== null;
                    },
                    placeBlock: (x, y, type) => {
                        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                           player.board[y][x] = Object.keys(COLORS).includes(type) ? type : null;
                        }
                    },
                },
            };
        };

        const p1Proxy = createPlayerProxy(players[0]);
        const p2Proxy = createPlayerProxy(players[1]);

        const gameApi = {
            win: (player) => { if (player instanceof Player) player.gameClear = true; },
            lose: (player) => { if (player instanceof Player) player.gameOver = true; },
            getTime: () => performance.now() - startTime,
            sendAttack: (player, lines) => {
                const targetPlayer = (player === p1Proxy && players[0]) ? players[0] :
                                     (player === p2Proxy && players[1]) ? players[1] : null;
                if (targetPlayer) {
                    targetPlayer.addGarbage(lines);
                }
            },
            p1: p1Proxy,
            p2: p2Proxy
        };
        
        players.forEach(p => p.gameApi = gameApi);
        
        autoStartParams = { ss: false, nh: false, hb: false };
        ctx.scale(RESOLUTION_SCALE, RESOLUTION_SCALE);

        if (gameSettings.touchControlsEnabled) {
            virtualController.show();
        }

        setTimeout(updateScale, 0);
    });


document.getElementById('backToEditorBtn').addEventListener('click', () => {
        gameState = 'EDITING';
        players = [];
        loadGameSettings();
        document.getElementById('game-container').style.display = 'none';
        document.getElementById('game-controls').style.display = 'none';
        document.getElementById('editor-container').style.display = 'flex';
        document.getElementById('rule-description-display').style.display = 'none';
        
        virtualController.hide();
        
        setTimeout(updateScale, 0);
    });
    
    ['p1', 'p2'].forEach(pId => { 
        document.getElementById(`imageLoader-${pId}`).addEventListener('change', e => { 
            if (e.target.files && e.target.files[0]) {
                startScanProcess(e.target.files[0], e.target.dataset.player);
            }
        }); 
        document.getElementById(`pptLoader-${pId}`).addEventListener('change', e => { 
            if (e.target.files && e.target.files[0]) {
                processPptImage(e.target.files[0]);
            }
        });
    });
    document.getElementById('scanCancelBtn').addEventListener('click', endScanProcess);
    document.getElementById('scanConfirmBtn').addEventListener('click', () => { if (gameState === 'SCAN_BL' && scanState.bottomLeft) gameState = 'SCAN_TR'; else if (gameState === 'SCAN_TR' && scanState.topRight) processAndLoadBoard(); updateScanUI(); });
    mainCanvas.addEventListener('click', e => { if (!gameState.startsWith('SCAN')) return; const rect = mainCanvas.getBoundingClientRect();
    const scaleX = mainCanvas.width / rect.width;
    const scaleY = mainCanvas.height / rect.height;
    const pos = { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    if (gameState==='SCAN_BL') scanState.bottomLeft=pos; else if (gameState==='SCAN_TR') scanState.topRight=pos; updateScanUI(); });
    

document.getElementById('settingsBtn').addEventListener('click', () => openUnifiedSettingsModal('general'));
    document.getElementById('p1-key-config-btn').addEventListener('click', () => openUnifiedSettingsModal('p1-keys'));
    document.getElementById('p2-key-config-btn').addEventListener('click', () => openUnifiedSettingsModal('p2-keys'));

    document.getElementById('settings-close').addEventListener('click', () => {
        saveGameSettings();
        try { localStorage.setItem('tetrisKeyBindings', JSON.stringify(keyBindings)); } 
        catch (e) { console.error("Failed to save key bindings to localStorage:", e); }

        document.getElementById('settings-modal').style.display = 'none';
        isBindingKey = false; bindingPlayer = null; bindingAction = null;
    });

    document.getElementById('vc-edit-layout-btn').addEventListener('click', () => {
        document.getElementById('settings-modal').style.display = 'none';
        virtualController.startEditMode();
    });

    document.getElementById('vc-save-and-close-btn').addEventListener('click', () => {
        virtualController.endEditMode();
    });
    document.getElementById('vc-copy-layout-btn').addEventListener('click', virtualController.copyLayoutsToClipboard);
    document.getElementById('vc-paste-layout-btn').addEventListener('click', virtualController.importLayoutsFromClipboard);

    document.addEventListener('keydown', e => {
        if (isBindingKey) {
            e.preventDefault();
            let keyLabel = e.key;
            if (keyLabel === ' ') keyLabel = 'Space';
            bindKey({ type: 'key', value: e.key.toLowerCase(), label: keyLabel });
        } 
        else if (gameState === 'PLAYING') {
            players.forEach(p => {
                p.keys[e.key.toLowerCase()] = true;
                Object.keys(p.keyBindings).forEach(action => {
                    const binding = p.keyBindings[action];
                    if (binding.type === 'key' && binding.value === e.key.toLowerCase()) {
                        p.handlePress(action);
                    }
                });
            });
        }
    });
    document.addEventListener('keyup', e => {
        if (gameState === 'PLAYING') {
            players.forEach(p => p.keys[e.key.toLowerCase()] = false );
        }
    });

    const manifest = {
        "name": "Tetris Simulator", "short_name": "TetrisSim", "start_url": ".",
        "display": "standalone", "background_color": "#1a1a2e", "theme_color": "#1a1a2e",
        "description": "A Tetris simulator with a 2-player mode and a powerful board editor.",
    "icons": [
        { "src": "https://raw.githubusercontent.com/selmtoe/Tetris_Simulator/main/icons/icon-192x192.png", "type": "image/png", "sizes": "192x192" },
        { "src": "https://raw.githubusercontent.com/selmtoe/Tetris_Simulator/main/icons/icon-512x512.png", "type": "image/png", "sizes": "512x512" }
    ]
    };
    const manifestURL = 'data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(manifest))));
    document.getElementById('manifest-link').setAttribute('href', manifestURL);
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tetris-sim-cache-v1';
            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME).then(cache => {
                        return cache.add(location.pathname);
                    })
                );
            });
            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request).then(response => {
                        return response || fetch(event.request);
                    })
                );
            });
        `;
        const blob = new Blob([swCode], { type: 'application/javascript' });
        navigator.serviceWorker.register(URL.createObjectURL(blob))
            .then(reg => console.log('Service Worker registered successfully.'))
            .catch(err => console.error('Service Worker registration failed:', err));
    }
    

document.getElementById('retryBtn').addEventListener('click', () => {
        if (gameState !== 'PLAYING' || !players.length) return;
        
        loadGameSettings();
        
        let currentRunSettings = { ...gameSettings };
        let userFunctions = {};
        let startTime = performance.now();
        const wasHoldDisabled = players[0].holdDisabled;

        if (editorData.rule.code) {
            try {
                const initApi = {
                    forceSetting: (key, value) => {
                        if (key in currentRunSettings) {
                            currentRunSettings[key] = value;
                        } else {
                            console.warn(`Rule tried to force unknown setting: ${key}`);
                        }
                    }
                };
                
                const combinedCode = editorData.rule.code + 
                    `\nreturn { 
                        onInit: typeof onInit === 'function' ? onInit : undefined,
                        onPieceLock: typeof onPieceLock === 'function' ? onPieceLock : undefined,
                        onUpdate: typeof onUpdate === 'function' ? onUpdate : undefined
                    };`;

                const ruleScript = new Function('api', combinedCode);
                const returnedFuncs = ruleScript(initApi);

                if (returnedFuncs.onInit) {
                    returnedFuncs.onInit(initApi);
                }
                userFunctions = returnedFuncs;

            } catch (e) {
                alert('リトライ時にカスタムルールコードの実行でエラーが発生しました:\n' + e.message);
                console.error("Custom rule script error on retry:", e);
                return;
            }
        }
        
        Object.assign(gameSettings, currentRunSettings);

        const createAndSetupPlayer = (id, offsetX, bindings, padIndex) => {
            const player = new Player(id, offsetX, bindings, padIndex);
            player.holdDisabled = wasHoldDisabled;
            player.ruleHooks = userFunctions;
            return player;
        };

        players = [];
        if (gameMode === '1P') {
            players.push(createAndSetupPlayer('1', 0, keyBindings.p1, 0));
        } else {
            const p1 = createAndSetupPlayer('1', 0, keyBindings.p1, 0);
            const p2 = createAndSetupPlayer('2', PLAYER_CANVAS_WIDTH, keyBindings.p2, 1);
            p1.opponent = p2;
            p2.opponent = p1;
            players.push(p1, p2);
        }

        const createPlayerProxy = (player) => {
            if (!player) return null;
            return {
                get stats() { return player.stats; },
                board: {
                    hasBlock: (x, y) => {
                        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT) return true;
                        return player.board[y][x] !== null;
                    },
                    placeBlock: (x, y, type) => {
                        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                           player.board[y][x] = Object.keys(COLORS).includes(type) ? type : null;
                        }
                    },
                },
            };
        };

        const p1Proxy = createPlayerProxy(players[0]);
        const p2Proxy = createPlayerProxy(players[1]);

        const gameApi = {
            win: (player) => { if (player instanceof Player) player.gameClear = true; },
            lose: (player) => { if (player instanceof Player) player.gameOver = true; },
            getTime: () => performance.now() - startTime,
            sendAttack: (player, lines) => {
                const targetPlayer = (player === p1Proxy && players[0]) ? players[0] :
                                     (player === p2Proxy && players[1]) ? players[1] : null;
                if (targetPlayer) {
                    targetPlayer.addGarbage(lines);
                }
            },
            p1: p1Proxy,
            p2: p2Proxy
        };
        
        players.forEach(p => p.gameApi = gameApi);
    });

    setupEditors();

    loadStateFromURL();

    lastTime = performance.now(); 
    requestAnimationFrame(gameLoop);
    
    window.addEventListener('resize', updateScale);
    setTimeout(updateScale, 100);
});
</script>
</body>
</html>
